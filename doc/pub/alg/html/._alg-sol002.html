<!--
File automatically generated using DocOnce (https://github.com/doconce/doconce/):
doconce format html main_alg.do.txt DOCUMENT=document APPENDIX=document BOOK=standalone --html_style=bootswatch_journal --html_code_style=inherit --html_output=alg-sol --allow_refs_to_external_docs
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Algorithms and implementations for exponential decay models">
<meta name="keywords" content="decay ODE,exponential decay,mesh,grid,mesh function,finite differences,forward difference,finite differences forward,difference equation,discrete equation,algebraic equation,finite difference scheme,Forward Euler scheme,backward difference,finite differences backward,backward scheme, 1-step,Backward Euler scheme,Crank-Nicolson scheme,centered difference,finite differences centered,averaging arithmetic,weighted average,theta-rule,$\theta$-rule,time step,finite difference operator notation,operator notation, finite differences,directory,folder,doc strings,printf format,format string syntax (Python),plotting curves,visualizing curves,test function,unit testing,representative (mesh function),array arithmetics,array computing,vectorization,continuous function norms,norm continuous,discrete function norms,mesh function norms,norm discrete (mesh function),error norms,scalar computing,PNG plot,PDF plot,EPS plot,viewing graphics files,cropping images,array arithmetics,array computing,vectorization">
<title>Algorithms and implementations for exponential decay models</title>
<!-- Bootstrap style: bootswatch_journal -->
<!-- doconce format html main_alg.do.txt DOCUMENT=document APPENDIX=document BOOK=standalone --html_style=bootswatch_journal --html_code_style=inherit --html_output=alg-sol --allow_refs_to_external_docs -->
<link href="https://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->
<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:60px;      /* fixed header height for style bootswatch_journal */
  margin:-60px 0 0; /* negative fixed header height */
}
</style>
</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Table of contents',
               1,
               'table_of_contents',
               'table_of_contents'),
              ('Finite difference methods', 1, 'decay:basics', 'decay:basics'),
              ('A basic model for exponential decay',
               2,
               'decay:model',
               'decay:model'),
              ('The exact solution', 3, None, 'the-exact-solution'),
              ('A complete problem formulation',
               3,
               None,
               'a-complete-problem-formulation'),
              ('The Forward Euler scheme',
               2,
               'decay:schemes:FE',
               'decay:schemes:FE'),
              ('Step 1: Discretizing the domain',
               3,
               None,
               'step-1-discretizing-the-domain'),
              ('Step 2: Fulfilling the equation at discrete time points',
               3,
               None,
               'step-2-fulfilling-the-equation-at-discrete-time-points'),
              ('Step 3: Replacing derivatives by finite differences',
               3,
               None,
               'step-3-replacing-derivatives-by-finite-differences'),
              ('Step 4: Formulating a recursive algorithm',
               3,
               None,
               'step-4-formulating-a-recursive-algorithm'),
              ('Interpretation', 3, None, 'interpretation'),
              ('Computing with the recursive formula',
               3,
               None,
               'computing-with-the-recursive-formula'),
              ('The Backward Euler scheme',
               2,
               'decay:schemes:BE',
               'decay:schemes:BE'),
              ('The Crank-Nicolson scheme',
               2,
               'decay:schemes:CN',
               'decay:schemes:CN'),
              ('The unifying $\\theta$-rule',
               2,
               'decay:schemes:theta',
               'decay:schemes:theta'),
              ('Constant time step', 2, None, 'constant-time-step'),
              ('Mathematical derivation of finite difference formulas',
               2,
               'decay:fd:taylor',
               'decay:fd:taylor'),
              ('The forward difference', 3, None, 'the-forward-difference'),
              ('The backward difference', 3, None, 'the-backward-difference'),
              ('The centered difference', 3, None, 'the-centered-difference'),
              ('Compact operator notation for finite differences',
               2,
               'decay:fd:op',
               'decay:fd:op'),
              ('Implementations', 1, 'decay:impl1', 'decay:impl1'),
              ('Computer language: Python',
               2,
               None,
               'computer-language-python'),
              ('Making a solver function', 2, 'decay:py1', 'decay:py1'),
              ('Integer division', 2, 'decay:py2', 'decay:py2'),
              ('Doc strings', 2, None, 'doc-strings'),
              ('Formatting numbers', 2, None, 'formatting-numbers'),
              ('Running the program', 2, None, 'running-the-program'),
              ('Plotting the solution', 2, None, 'plotting-the-solution'),
              ('Verifying the implementation',
               2,
               None,
               'verifying-the-implementation'),
              ('Running a few algorithmic steps by hand',
               3,
               None,
               'running-a-few-algorithmic-steps-by-hand'),
              ('Computing the numerical error as a mesh function',
               2,
               'decay:computing:error',
               'decay:computing:error'),
              ('Computing the norm of the error mesh function',
               2,
               'decay:computing:error:norm',
               'decay:computing:error:norm'),
              ('Scalar computing', 3, None, 'scalar-computing'),
              ('Experiments with computing and plotting',
               2,
               None,
               'experiments-with-computing-and-plotting'),
              ('Combining plot files', 3, None, 'combining-plot-files'),
              ('Plotting with SciTools', 3, None, 'plotting-with-scitools'),
              ('Memory-saving implementation',
               2,
               None,
               'memory-saving-implementation'),
              ('Exercises', 1, None, 'exercises'),
              ('Exercise 1: Define a mesh function and visualize it',
               2,
               'decay:exer:meshfunc',
               'decay:exer:meshfunc'),
              ('Remarks', 3, None, 'remarks'),
              ('Problem 2: Differentiate a function',
               2,
               'decay:exer:dudt',
               'decay:exer:dudt'),
              ('Problem 3: Experiment with divisions',
               2,
               'decay:exer:intdiv',
               'decay:exer:intdiv'),
              ('Problem 4: Experiment with wrong computations',
               2,
               'decay:exer:decay1err',
               'decay:exer:decay1err'),
              ('Problem 5: Plot the error function',
               2,
               'decay:exer:plot:error',
               'decay:exer:plot:error'),
              ('Problem 6: Change formatting of numbers and debug',
               2,
               'decay:exer:inexact:output',
               'decay:exer:inexact:output'),
              ('Bibliography', 1, None, 'bibliography')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
$$



<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="alg-so.html">Algorithms and implementations for exponential decay models</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._alg-sol000.html#table_of_contents" style="font-size: 80%;"><b>Table of contents</b></a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#decay:basics" style="font-size: 80%;"><b>Finite difference methods</b></a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#decay:model" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A basic model for exponential decay</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#the-exact-solution" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The exact solution</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#a-complete-problem-formulation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A complete problem formulation</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#decay:schemes:FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Forward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#step-1-discretizing-the-domain" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 1: Discretizing the domain</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#step-2-fulfilling-the-equation-at-discrete-time-points" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 2: Fulfilling the equation at discrete time points</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#step-3-replacing-derivatives-by-finite-differences" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 3: Replacing derivatives by finite differences</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#step-4-formulating-a-recursive-algorithm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 4: Formulating a recursive algorithm</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#interpretation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interpretation</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#computing-with-the-recursive-formula" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing with the recursive formula</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#decay:schemes:BE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Backward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#decay:schemes:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Crank-Nicolson scheme</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#decay:schemes:theta" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The unifying \( \theta \)-rule</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#constant-time-step" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Constant time step</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#decay:fd:taylor" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Mathematical derivation of finite difference formulas</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#the-forward-difference" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The forward difference</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#the-backward-difference" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The backward difference</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#the-centered-difference" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The centered difference</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol001.html#decay:fd:op" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Compact operator notation for finite differences</a></li>
     <!-- navigation toc: --> <li><a href="#decay:impl1" style="font-size: 80%;"><b>Implementations</b></a></li>
     <!-- navigation toc: --> <li><a href="#computer-language-python" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computer language: Python</a></li>
     <!-- navigation toc: --> <li><a href="#decay:py1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Making a solver function</a></li>
     <!-- navigation toc: --> <li><a href="#decay:py2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Integer division</a></li>
     <!-- navigation toc: --> <li><a href="#doc-strings" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Doc strings</a></li>
     <!-- navigation toc: --> <li><a href="#formatting-numbers" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Formatting numbers</a></li>
     <!-- navigation toc: --> <li><a href="#running-the-program" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Running the program</a></li>
     <!-- navigation toc: --> <li><a href="#plotting-the-solution" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Plotting the solution</a></li>
     <!-- navigation toc: --> <li><a href="#verifying-the-implementation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Verifying the implementation</a></li>
     <!-- navigation toc: --> <li><a href="#running-a-few-algorithmic-steps-by-hand" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running a few algorithmic steps by hand</a></li>
     <!-- navigation toc: --> <li><a href="#decay:computing:error" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing the numerical error as a mesh function</a></li>
     <!-- navigation toc: --> <li><a href="#decay:computing:error:norm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing the norm of the error mesh function</a></li>
     <!-- navigation toc: --> <li><a href="#scalar-computing" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scalar computing</a></li>
     <!-- navigation toc: --> <li><a href="#experiments-with-computing-and-plotting" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Experiments with computing and plotting</a></li>
     <!-- navigation toc: --> <li><a href="#combining-plot-files" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combining plot files</a></li>
     <!-- navigation toc: --> <li><a href="#plotting-with-scitools" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting with SciTools</a></li>
     <!-- navigation toc: --> <li><a href="#memory-saving-implementation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Memory-saving implementation</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol003.html#exercises" style="font-size: 80%;"><b>Exercises</b></a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol003.html#decay:exer:meshfunc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 1: Define a mesh function and visualize it</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol003.html#remarks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol003.html#decay:exer:dudt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 2: Differentiate a function</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol003.html#decay:exer:intdiv" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 3: Experiment with divisions</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol003.html#decay:exer:decay1err" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 4: Experiment with wrong computations</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol003.html#decay:exer:plot:error" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 5: Plot the error function</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol003.html#decay:exer:inexact:output" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 6: Change formatting of numbers and debug</a></li>
     <!-- navigation toc: --> <li><a href="._alg-sol004.html#bibliography" style="font-size: 80%;"><b>Bibliography</b></a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->
<div class="container">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->
<a name="part0002"></a>
<!-- !split -->
<h1 id="decay:impl1" class="anchor">Implementations</h1>

<p>We want to make a computer program for solving</p>
$$
u^{\prime}(t) = -au(t),\quad t\in (0,T], \quad u(0)=I,
$$

<p>by finite difference methods. The program should also display
the numerical solution as a curve on the
screen, preferably together with the
exact solution.
</p>

<p>All programs referred to in this section are found in the
<a href="http://tinyurl.com/ofkw6kc/alg" target="_self"><tt>src/alg</tt></a> directory (we use the classical
Unix term <em>directory</em> for what many others nowadays call <em>folder</em>).
</p>

<p>
<b>Mathematical problem.</b>
We want to explore the Forward Euler scheme, the
Backward Euler, and the Crank-Nicolson schemes applied to our model problem.
From an implementational point of view, it is advantageous to
implement the \( \theta \)-rule
</p>
$$
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,
$$

<p>since it can generate the three other schemes by various
choices of \( \theta \): \( \theta=0 \) for Forward Euler, \( \theta =1 \) for
Backward Euler, and \( \theta =1/2 \) for Crank-Nicolson.
Given \( a \), \( u^0=I \), \( T \), and \( \Delta t \),
our task is to use the \( \theta \)-rule to
compute \( u^1, u^2,\ldots,u^{N_t} \), where \( t_{N_t}=N_t\Delta t \), and
\( N_t \) the closest integer to \( T/\Delta t \).
</p>
<h2 id="computer-language-python" class="anchor">Computer language: Python </h2>

<p>Any programming language can be used to generate the \( u^{n+1} \) values from
the formula above. However, in this document we shall mainly make use of
Python. There are several good reasons for this choice:
</p>

<ul>
  <li> Python has a very clean, readable syntax (often known as "executable pseudo-code").</li>
  <li> Python code is very similar to MATLAB code (and MATLAB has a particularly widespread use for scientific computing).</li>
  <li> Python is a full-fledged, very powerful programming language.</li>
  <li> Python is similar to C++, but is much simpler to work with and results in more reliable code.</li>
  <li> Python has a rich set of modules for scientific computing, and its popularity in scientific computing is rapidly growing.</li>
  <li> Python was made for being combined with compiled languages (C, C++, Fortran), so that existing numerical software can be reused, and thereby easing high computational performance with new implementations.</li>
  <li> Python has extensive support for administrative tasks needed when doing large-scale computational investigations.</li>
  <li> Python has extensive support for graphics (visualization, user interfaces, web applications).</li>
</ul>
<p>Learning Python is easy. Many newcomers to the language will probably
learn enough from the forthcoming examples to perform their own computer
experiments. The examples start with simple Python code and gradually
make use of more powerful constructs as we proceed. Unless it is
inconvenient for the problem at hand, our Python code is made as
close as possible to MATLAB code for easy transition between the two
languages.
</p>

<p>The coming programming examples assumes familiarity with
variables, for loops, lists, arrays,
functions, positional arguments, and keyword (named) arguments.
A background in basic MATLAB programming is often enough to understand
Python examples.
Readers who feel the Python examples are too hard to follow will
benefit from reading a tutorial, e.g.,
</p>

<ul>
  <li> <a href="http://docs.python.org/2/tutorial/" target="_self">The Official Python Tutorial</a></li>
  <li> <a href="http://www.tutorialspoint.com/python/" target="_self">Python Tutorial on tutorialspoint.com</a></li>
  <li> <a href="http://www.learnpython.org/" target="_self">Interactive Python tutorial site</a></li>
  <li> <a href="http://en.wikibooks.org/wiki/A_Beginner's_Python_Tutorial" target="_self">A Beginner's Python Tutorial</a></li>
</ul>
<p>The author also has a comprehensive book <a href="._alg-sol004.html#Langtangen_2012">[1]</a> that teaches
scientific programming with Python from the ground up.
</p>

<!-- bumpy list of refs? -->
<h2 id="decay:py1" class="anchor">Making a solver function</h2>

<p>We choose to have an array <code>u</code> for storing the \( u^n \) values, \( n=0,1,\ldots,N_t \).
The algorithmic steps are
</p>

<ol>
 <li> initialize \( u^0 \)</li>
 <li> for \( t=t_n \), \( n=1,2,\ldots,N_t \): compute \( u_n \) using the \( \theta \)-rule formula</li>
</ol>
<p>An implementation of a numerical algorithm is often referred to as
a <em>solver</em>. We shall now make a solver for our model problem and
realize the solver as a Python function. The function must take
the input data \( I \), \( a \), \( T \), \( \Delta t \), and \( \theta \) of the problem
as arguments and return the solution as arrays <code>u</code> and <code>t</code> for
\( u^n \) and \( t^n \), \( n=0,\ldots,N_t \). The solver function used as
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">u, t <span style="color: #666666">=</span> solver(I, a, T, dt, theta)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>One can now easily plot <code>u</code> versus <code>t</code> to visualize the solution.</p>

<p>The function <code>solver</code> may look as follows in Python:</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(I, a, T, dt, theta):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(T<span style="color: #666666">/</span>dt)            <span style="color: #3D7B7B; font-style: italic"># no of time intervals</span>
    T <span style="color: #666666">=</span> Nt<span style="color: #666666">*</span>dt                 <span style="color: #3D7B7B; font-style: italic"># adjust T to fit time step dt</span>
    u <span style="color: #666666">=</span> zeros(Nt<span style="color: #666666">+1</span>)           <span style="color: #3D7B7B; font-style: italic"># array of u[n] values</span>
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)  <span style="color: #3D7B7B; font-style: italic"># time mesh</span>

    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I                  <span style="color: #3D7B7B; font-style: italic"># assign initial condition</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):    <span style="color: #3D7B7B; font-style: italic"># n=0,1,...,Nt-1</span>
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)<span style="color: #666666">*</span>u[n]
    <span style="color: #008000; font-weight: bold">return</span> u, t
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The <code>numpy</code> library contains a lot of functions for array computing. Most
of the function names are similar to what is found
in the alternative scientific computing language MATLAB. Here
we make use of
</p>

<ul>
 <li> <code>zeros(Nt+1)</code> for creating an array of size <code>Nt+1</code> and initializing the elements to zero</li>
 <li> <code>linspace(0, T, Nt+1)</code> for creating an array with <code>Nt+1</code> coordinates uniformly distributed between <code>0</code> and <code>T</code></li>
</ul>
<p>The <code>for</code> loop deserves a comment, especially for newcomers to Python.
The construction <code>range(0, Nt, s)</code> generates all integers from <code>0</code> to <code>Nt</code>
in steps of <code>s</code>, <em>but not including</em> <code>Nt</code>. Omitting <code>s</code> means <code>s=1</code>.
For example, <code>range(0, 6, 3)</code>
gives <code>0</code> and <code>3</code>, while <code>range(0, 6)</code> generates
the list <code>[0, 1, 2, 3, 4, 5]</code>.
Our loop implies the following assignments to <code>u[n+1]</code>: <code>u[1]</code>, <code>u[2]</code>, ...,
<code>u[Nt]</code>, which is what we want since <code>u</code> has length <code>Nt+1</code>.
The first index in Python arrays or lists is <em>always</em> <code>0</code> and the
last is then <code>len(u)-1</code> (the length of an array <code>u</code> is obtained by
<code>len(u)</code> or <code>u.size</code>).
</p>
<h2 id="decay:py2" class="anchor">Integer division</h2>

<p>The shown implementation of the <code>solver</code> may face problems and
wrong results if <code>T</code>, <code>a</code>, <code>dt</code>, and <code>theta</code> are given as integers
(see <a href="._alg-sol003.html#decay:exer:intdiv">Problem 3: Experiment with divisions</a> and <a href="._alg-sol003.html#decay:exer:decay1err">Problem 4: Experiment with wrong computations</a>).
The problem is related to <em>integer division</em> in Python (as
in Fortran, C, C++, and many other computer languages!): <code>1/2</code> becomes <code>0</code>,
while <code>1.0/2</code>, <code>1/2.0</code>, or <code>1.0/2.0</code> all become <code>0.5</code>. So, it is enough
that at least the nominator or the denominator is a real number
(i.e., a <code>float</code> object)
to ensure a correct mathematical division. Inserting
a conversion <code>dt = float(dt)</code>
guarantees that <code>dt</code> is
<code>float</code>.
</p>

<p>Another problem with computing \( N_t=T/\Delta t \) is that we should
round \( N_t \) to the nearest integer. With <code>Nt = int(T/dt)</code> the <code>int</code>
operation picks the largest integer smaller than <code>T/dt</code>. Correct
mathematical rounding as known from school is obtained by
</p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The complete version of our improved, safer <code>solver</code> function then becomes</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(I, a, T, dt, theta):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)            <span style="color: #3D7B7B; font-style: italic"># avoid integer division</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))     <span style="color: #3D7B7B; font-style: italic"># no of time intervals</span>
    T <span style="color: #666666">=</span> Nt<span style="color: #666666">*</span>dt                 <span style="color: #3D7B7B; font-style: italic"># adjust T to fit time step dt</span>
    u <span style="color: #666666">=</span> zeros(Nt<span style="color: #666666">+1</span>)           <span style="color: #3D7B7B; font-style: italic"># array of u[n] values</span>
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)  <span style="color: #3D7B7B; font-style: italic"># time mesh</span>
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I                  <span style="color: #3D7B7B; font-style: italic"># assign initial condition</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):    <span style="color: #3D7B7B; font-style: italic"># n=0,1,...,Nt-1</span>
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)<span style="color: #666666">*</span>u[n]
    <span style="color: #008000; font-weight: bold">return</span> u, t
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
<h2 id="doc-strings" class="anchor">Doc strings </h2>

<p>Right below the header line in the <code>solver</code> function there is a
Python string enclosed in triple double quotes <code>&quot;&quot;&quot;</code>.
The purpose of this string object is to document what the function
does and what the arguments are. In this case the necessary
documentation does not span more than one line, but with triple double
quoted strings the text may span several lines:
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(I, a, T, dt, theta):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve</span>

<span style="color: #BA2121; font-style: italic">        u&#39;(t) = -a*u(t),</span>

<span style="color: #BA2121; font-style: italic">    with initial condition u(0)=I, for t in the time interval</span>
<span style="color: #BA2121; font-style: italic">    (0,T]. The time interval is divided into time steps of</span>
<span style="color: #BA2121; font-style: italic">    length dt.</span>

<span style="color: #BA2121; font-style: italic">    theta=1 corresponds to the Backward Euler scheme, theta=0</span>
<span style="color: #BA2121; font-style: italic">    to the Forward Euler scheme, and theta=0.5 to the Crank-</span>
<span style="color: #BA2121; font-style: italic">    Nicolson method.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #666666">...</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Such documentation strings appearing right after the header of
a function are called <em>doc strings</em>. There are tools that can automatically
produce nicely formatted documentation by extracting the definition of
functions and the contents of doc strings.
</p>

<p>It is strongly recommended to equip any function with a doc string,
unless the purpose of the function
is not obvious. Nevertheless, the forthcoming
text deviates from this rule if the function is explained in the text.
</p>
<h2 id="formatting-numbers" class="anchor">Formatting numbers </h2>

<p>Having computed the discrete solution <code>u</code>, it is natural to look at
the numbers:
</p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #3D7B7B; font-style: italic"># Write out a table of t and u values:</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(t)):
    <span style="color: #008000">print</span> t[i], u[i]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>This compact <code>print</code> statement unfortunately gives less readable output
because the <code>t</code> and <code>u</code> values are not aligned in nicely formatted columns.
To fix this problem, we recommend to use the <em>printf format</em>, supported in most
programming languages inherited from C. Another choice is
Python's recent <em>format string syntax</em>. Both kinds of syntax are illustrated
below.
</p>

<p>Writing <code>t[i]</code> and <code>u[i]</code> in two nicely formatted columns is done like
this with the printf format:
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000">print</span> <span style="color: #BA2121">&#39;t=</span><span style="color: #A45A77; font-weight: bold">%6.3f</span><span style="color: #BA2121"> u=</span><span style="color: #A45A77; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t[i], u[i])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The percentage signs signify "slots" in the text where the variables
listed at the end of the statement are inserted. For each "slot" one
must specify a format for how the variable is going to appear in the
string: <code>f</code> for float (with 6 decimals),
<code>s</code> for pure text, <code>d</code> for an integer, <code>g</code> for a real number
written as compactly as possible, <code>9.3E</code> for scientific notation with
three decimals in a field of width 9 characters (e.g., <code>-1.351E-2</code>),
or <code>.2f</code> for standard decimal notation with two decimals
formatted with minimum width. The printf syntax provides a quick way
of formatting tabular output of numbers with full control of the
layout.
</p>

<p>The alternative <em>format string syntax</em> looks like</p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000">print</span> <span style="color: #BA2121">&#39;t=</span><span style="color: #A45A77; font-weight: bold">{t:6.3f}</span><span style="color: #BA2121"> u=</span><span style="color: #A45A77; font-weight: bold">{u:g}</span><span style="color: #BA2121">&#39;</span><span style="color: #666666">.</span>format(t<span style="color: #666666">=</span>t[i], u<span style="color: #666666">=</span>u[i])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>As seen, this format allows logical names in the "slots" where
<code>t[i]</code> and <code>u[i]</code> are to be inserted. The "slots" are surrounded
by curly braces, and the logical name is followed by a colon and
then the printf-like specification of how to format real numbers,
integers, or strings.
</p>
<h2 id="running-the-program" class="anchor">Running the program </h2>

<p>The function and main program shown above must be placed in a file,
say with name <a href="http://tinyurl.com/ofkw6kc/alg/decay_v1.py" target="_self"><tt>decay_v1.py</tt></a> (<code>v1</code> for 1st version of this program).  Make sure you
write the code with a suitable text editor (Gedit, Emacs, Vim,
Notepad++, or similar).  The program is run by executing the file this
way:
</p>


<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">Terminal&gt; python decay_v1.py
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The text <code>Terminal&gt;</code> just indicates a prompt in a
Unix/Linux or DOS terminal window. After this prompt, which may look
different in your terminal window (depending on the terminal application
and how it is set up), commands like <code>python decay_v1.py</code> can be issued.
These commands are interpreted by the operating system.
</p>

<p>We strongly recommend to run Python programs within the IPython shell.
First start IPython by typing <code>ipython</code> in the terminal window.
Inside the IPython shell, our program <code>decay_v1.py</code> is run by the command
<code>run decay_v1.py</code>:
</p>


<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">Terminal&gt; ipython

In [1]: run decay_v1.py
t= 0.000 u=1
t= 0.800 u=0.384615
t= 1.600 u=0.147929
t= 2.400 u=0.0568958
t= 3.200 u=0.021883
t= 4.000 u=0.00841653
t= 4.800 u=0.00323713
t= 5.600 u=0.00124505
t= 6.400 u=0.000478865
t= 7.200 u=0.000184179
t= 8.000 u=7.0838e-05
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The advantage of running programs in IPython are many, but here
we explicitly mention a few of the most
useful features:
</p>

<ul>
 <li> previous commands are easily recalled with the up arrow,</li>
 <li> <code>%pdb</code> turns on a debugger so that variables can be examined if the program aborts (due to a Python exception),</li>
 <li> output of commands are stored in variables,</li>
 <li> the computing time spent on a set of statements can be measured with the <code>%timeit</code> command,</li>
 <li> any operating system command can be executed,</li>
 <li> modules can be loaded automatically and other customizations can be performed when starting IPython</li>
</ul>
<p>Although running programs in IPython is strongly recommended, most
execution examples in the forthcoming text use the standard
Python shell with prompt <code>&gt;&gt;&gt;</code> and run programs through
a typesetting like
</p>


<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">Terminal&gt; python programname
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The reason is that such typesetting
makes the text more compact in the vertical direction
than showing sessions with IPython syntax.
</p>

<div id="decay:plotting"></div>
<h2 id="plotting-the-solution" class="anchor">Plotting the solution </h2>

<p>Having the <code>t</code> and <code>u</code> arrays, the approximate solution <code>u</code> is visualized
by the intuitive command <code>plot(t, u)</code>:
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
plot(t, u)
show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>It will be illustrative to also plot the exact solution
\( \uex(t)=Ie^{-at} \) for comparison. We first
need to make a Python function for computing the exact solution:
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u_exact</span>(t, I, a):
    <span style="color: #008000; font-weight: bold">return</span> I<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>It is tempting to just do</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">u_e <span style="color: #666666">=</span> u_exact(t, I, a)
plot(t, u, t, u_e)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>However, this is not exactly what we want: the <code>plot</code> function draws
straight lines between the discrete points <code>(t[n], u_e[n])</code> while
\( \uex(t) \) varies as an exponential function between the mesh points.
The technique for showing the &quot;exact&quot; variation of \( \uex(t) \) between
the mesh points is to introduce a very fine mesh for \( \uex(t) \):
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">t_e <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, <span style="color: #666666">1001</span>)      <span style="color: #3D7B7B; font-style: italic"># fine mesh</span>
u_e <span style="color: #666666">=</span> u_exact(t_e, I, a)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We can also plot the curves with different colors and styles, e.g.,</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">plot(t_e, u_e, <span style="color: #BA2121">&#39;b-&#39;</span>,         <span style="color: #3D7B7B; font-style: italic"># blue line for u_e</span>
     t,   u,   <span style="color: #BA2121">&#39;r--o&#39;</span>)       <span style="color: #3D7B7B; font-style: italic"># red dashes w/circles</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>With more than one curve in the plot we need to associate each curve
with a legend. We also want appropriate names on the axes, a title,
and a file containing the plot as an image for inclusion in reports.
The Matplotlib package (<code>matplotlib.pyplot</code>) contains functions for
this purpose. The names of the functions are similar to the plotting
functions known from MATLAB.  A complete function for creating
the comparison plot becomes
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plot_numerical_and_exact</span>(theta, I, a, T, dt):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Compare the numerical and exact solution in a plot.&quot;&quot;&quot;</span>
    u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, T<span style="color: #666666">=</span>T, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)
    t_e <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, <span style="color: #666666">1001</span>)        <span style="color: #3D7B7B; font-style: italic"># fine mesh for u_e</span>
    u_e <span style="color: #666666">=</span> u_exact(t_e, I, a)
    plot(t, u, <span style="color: #BA2121">&#39;r--o&#39;</span>, t_e, u_e, <span style="color: #BA2121">&#39;b-&#39;</span>)
    legend([<span style="color: #BA2121">&#39;numerical&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>])
    xlabel(<span style="color: #BA2121">&#39;t&#39;</span>); ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
    title(<span style="color: #BA2121">&#39;theta=</span><span style="color: #A45A77; font-weight: bold">%g</span><span style="color: #BA2121">, dt=</span><span style="color: #A45A77; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (theta, dt))
    savefig(<span style="color: #BA2121">&#39;plot_</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">_</span><span style="color: #A45A77; font-weight: bold">%g</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> (theta, dt))
plot_numerical_and_exact(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=2</span>, T<span style="color: #666666">=8</span>, dt<span style="color: #666666">=0.8</span>, theta<span style="color: #666666">=1</span>)
show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Note that <code>savefig</code> here creates a PNG file whose name includes the
values of \( \theta \) and \( \Delta t \) so that we can easily distinguish
files from different runs with \( \theta \) and \( \Delta t \).
</p>

<p>The complete code is found in the file
<a href="http://tinyurl.com/ofkw6kc/alg/decay_v2.py" target="_self"><tt>decay_v2.py</tt></a>. The resulting plot
is shown in Figure <a href="#decay:fig:v2">7</a>. As seen, there is quite some
discrepancy between the exact and the numerical solution.
Fortunately, the numerical solution approaches the exact one as
\( \Delta t \) is reduced.
</p>

<center> <!-- figure label: --> <div id="decay:fig:v2"></div> <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 7: Comparison of numerical and exact solution.  <!-- caption label: decay:fig:v2 --></p>
</center>
<p><img src="fig-alg/decay_v2.png" width="500" align="bottom"></p>
</center>

<h2 id="verifying-the-implementation" class="anchor">Verifying the implementation </h2>

<p>It is easy to make mistakes while deriving and implementing numerical
algorithms, so we should never believe in the solution before it has
been thoroughly verified.
</p>

<div class="alert alert-block alert-success alert-text-normal"><b>Verification and validation</b>
<p>The purpose of <em>verifying</em> a program is to bring evidence for the
property that there are no errors in the implementation. A related
term, <em>validate</em> (and <em>validation</em>),
addresses the question if the ODE model is a good
representation of the phenomena we want to simulate. To remember the
difference between verification and validation, verification is
about <em>solving the equations right</em>, while validation is about <em>solving
the right equations</em>. We must always perform a verification before
it is meaningful to believe in the computations and perform validation
(which compares the program results with physical experiments or observations).
</p>
</div>


<p>The most obvious idea for verification
in our case is to compare the numerical solution with the exact
solution, when that exists. This is, however, not a particularly good
method. The reason is that there will always
be a discrepancy
between these two solutions, due to numerical
approximations, and we cannot precisely quantify the approximation
errors. The open question is therefore whether we have the
mathematically correct
discrepancy or if we have another, maybe small,
discrepancy due to both an approximation error <em>and</em> an error in the
implementation. It is thus
impossible to judge whether the program is correct or not by
just looking at the graphs in Figure <a href="#decay:fig:v2">7</a>.
</p>

<p>To avoid
mixing the unavoidable numerical approximation errors and the
undesired implementation errors, we should try to make tests where
we have some exact
computation of the discrete solution or at least parts of it.
Examples will show how this can be done.
</p>
<h3 id="running-a-few-algorithmic-steps-by-hand" class="anchor">Running a few algorithmic steps by hand </h3>

<p>The simplest approach to produce a correct non-trivial reference
solution for the discrete solution \( u \), is to compute a few steps of
the algorithm by hand. Then we can compare the hand calculations with
numbers produced by the program.
</p>

<p>A straightforward approach is to use a calculator and
compute \( u^1 \), \( u^2 \), and \( u^3 \). With \( I=0.1 \), \( \theta=0.8 \),
and \( \Delta t =0.8 \) we get
</p>

$$ A\equiv \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t} = 0.298245614035$$

$$
\begin{align*}
u^1 &= AI=0.0298245614035,\\ 
u^2 &= Au^1= 0.00889504462912,\\ 
u^3 &=Au^2= 0.00265290804728
\end{align*}
$$

<p>Comparison of these manual calculations with the result of the
<code>solver</code> function is carried out in the function
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solver_three_steps</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Compare three steps with known manual computations.&quot;&quot;&quot;</span>
    theta <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>; a <span style="color: #666666">=</span> <span style="color: #666666">2</span>; I <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>; dt <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>
    u_by_hand <span style="color: #666666">=</span> array([I,
                       <span style="color: #666666">0.0298245614035</span>,
                       <span style="color: #666666">0.00889504462912</span>,
                       <span style="color: #666666">0.00265290804728</span>])

    Nt <span style="color: #666666">=</span> <span style="color: #666666">3</span>  <span style="color: #3D7B7B; font-style: italic"># number of time steps</span>
    u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, T<span style="color: #666666">=</span>Nt<span style="color: #666666">*</span>dt, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)

    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>  <span style="color: #3D7B7B; font-style: italic"># tolerance for comparing floats</span>
    diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u <span style="color: #666666">-</span> u_by_hand)<span style="color: #666666">.</span>max()
    success <span style="color: #666666">=</span> diff <span style="color: #666666">&lt;</span> tol
    <span style="color: #008000; font-weight: bold">assert</span> success
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The <code>test_solver_three_steps</code> function follows widely used conventions
for <em>unit testing</em>. By following such conventions we can at a later
stage easily execute a big test suite for our software. That is, after
a small modification is made to the program, we can by typing just
a short command, run through a large number of tests to check that the
modifications do not break any computations.
The conventions boil down to three rules:
</p>

<ul>
 <li> The test function name must start with <code>test_</code> and the function cannot take any arguments.</li>
 <li> The test must end up in a boolean expression that is <code>True</code> if the test was passed and <code>False</code> if it failed.</li>
 <li> The function must run <code>assert</code> on the boolean expression, resulting in program abortion (due to an <code>AssertionError</code> exception) if the test failed.</li>
</ul>
<p>A typical <code>assert</code> statement is to check that a computed result <code>c</code>
equals the expected value <code>e</code>: <code>assert c == e</code>. However, since real
numbers are stored in a computer using only 64 units, most numbers
will feature a small rounding error, typically of size \( 10^{-16} \).
That is, real numbers on a computer have finite precision. When doing
arithmetics with finite precision numbers, the rounding errors may
accumulate or not, depending on the algorithm.  It does not make sense
to test <code>c == e</code>, since a small rounding error will cause the test to
fail. Instead, we use an equality with <em>tolerance</em> <code>tol</code>: <code>abs(e - c)
&lt; tol</code>. The <code>test_solver_three_steps</code> functions applies this type of
test with a tolerance \( 01^{-15} \).
</p>

<p>The main program can routinely run the verification test prior to
solving the real problem:
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">test_solver_three_steps()
plot_numerical_and_exact(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=2</span>, T<span style="color: #666666">=8</span>, dt<span style="color: #666666">=0.8</span>, theta<span style="color: #666666">=1</span>)
show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>(Rather than calling <code>test_*()</code> functions explicitly, one will
normally ask a testing framework like nose
or pytest to find and run such functions.)
The complete program including the verification above is
found in the file <a href="http://tinyurl.com/ofkw6kc/alg/decay_v3.py" target="_self"><tt>decay_v3.py</tt></a>.
</p>
<h2 id="decay:computing:error" class="anchor">Computing the numerical error as a mesh function</h2>

<p>Now that we have some evidence for a correct implementation, we are in
position to compare the computed \( u^n \) values in the <code>u</code> array with
the exact \( u \) values at the mesh points, in order to study the error
in the numerical solution.
</p>

<p>A natural way to compare the exact and discrete solutions is to
calculate their difference as a mesh function for the error:
</p>

$$
\begin{equation}
e^n = \uex(t_n) - u^n,\quad n=0,1,\ldots,N_t \tp
\tag{46}
\end{equation}
$$

<p>We may view the mesh function
\( \uex^n = \uex(t_n) \) as a representation of the continuous function \( \uex(t) \)
defined for all \( t\in [0,T] \). In fact,
\( \uex^n \) is often called the <em>representative</em> of
\( \uex \) on the mesh. Then, \( e^n = \uex^n - u^n \) is clearly
the difference of two mesh functions.
</p>

<p>The error mesh function \( e^n \) can be computed by</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">u, t <span style="color: #666666">=</span> solver(I, a, T, dt, theta)  <span style="color: #3D7B7B; font-style: italic"># Numerical sol.</span>
u_e <span style="color: #666666">=</span> u_exact(t, I, a)             <span style="color: #3D7B7B; font-style: italic"># Representative of exact sol.</span>
e <span style="color: #666666">=</span> u_e <span style="color: #666666">-</span> u
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Note that the mesh functions <code>u</code> and <code>u_e</code> are represented by arrays
and associated with the points in the array <code>t</code>.
</p>

<div class="alert alert-block alert-success alert-text-normal"><b>Array arithmetics</b>
<p>The last statements</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #ffffff">
  <pre style="line-height: 125%;">u_e <span style="color: #666666">=</span> u_exact(t, I, a)
e <span style="color: #666666">=</span> u_e <span style="color: #666666">-</span> u
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>demonstrate some standard examples of array arithmetics: <code>t</code> is an
array of mesh points that we pass to <code>u_exact</code>. This function
evaluates <code>-a*t</code>, which is a scalar times an array, meaning that
the scalar is multiplied with each array element.
The result is an array, let us call it <code>tmp1</code>. Then
<code>exp(tmp1)</code> means applying the exponential function to each element in
<code>tmp1</code>, giving an array, say <code>tmp2</code>. Finally, <code>I*tmp2</code> is computed
(scalar times array) and <code>u_e</code> refers to this array returned from
<code>u_exact</code>. The expression <code>u_e - u</code> is the difference between
two arrays, resulting in a new array referred to by <code>e</code>.
</p>

<p>Replacement of array element computations inside a loop by array
arithmetics is known as <em>vectorization</em>.
</p>
</div>

<h2 id="decay:computing:error:norm" class="anchor">Computing the norm of the error mesh function</h2>

<p>Instead of working with the error \( e^n \) on the entire mesh, we
often want a single number expressing the size of the error.
This is obtained by taking the norm of the error function.
</p>

<p>Let us first define norms of a function \( f(t) \)
defined for all \( t\in [0,T] \).
Three common norms are
</p>

$$
\begin{align}
||f||_{L^2} &= \left( \int_0^T f(t)^2 dt\right)^{1/2},
\tag{47}\\ 
||f||_{L^1} &= \int_0^T |f(t)| dt,
\tag{48}\\ 
||f||_{L^\infty} &= \max_{t\in [0,T]}|f(t)|\tp
\tag{49}
\end{align}
$$

<p>The \( L^2 \) norm <a href="#mjx-eqn-47">(47)</a> (&quot;L-two norm&quot;)
has nice mathematical properties and
is the most popular norm. It is a generalization
of the well-known Eucledian norm of vectors to functions.
The \( L^1 \) norm looks simpler and more intuitive, but has less
nice mathematical properties compared to the two other norms, so
it is much less used in computations.
The \( L^\infty \) is also called the max norm or the supremum norm
and is widely used. It focuses on a single point with the largest
value of \( |f| \), while the other norms measure average behavior of
the function.
</p>

<p>In fact, there is a whole family of norms,</p>

$$
\begin{equation}
||f||_{L^p} = \left(\int_0^T f(t)^pdt\right)^{1/p},
\tag{50}
\end{equation}
$$

<p>with \( p \) real. In particular,
\( p=1 \) corresponds to the \( L^1 \) norm above while \( p=\infty \) is the
\( L^\infty \) norm.
</p>

<p>Numerical computations involving mesh functions need corresponding norms.
Given a set of function values, \( f^n \), and some associated mesh points, \( t_n \),
a numerical integration rule can be used to calculate the \( L^2 \) and
\( L^1 \) norms defined above. Imagining that the mesh function is extended
to vary linearly between the mesh points, the Trapezoidal rule is
in fact an exact integration rule. A possible modification of the \( L^2 \)
norm for a mesh function \( f^n \) on a uniform mesh with spacing \( \Delta t \)
is therefore the well-known Trapezoidal integration formula
</p>

$$ ||f^n|| = \left(\Delta t\left(\half(f^0)^2 + \half(f^{N_t})^2
+ \sum_{n=1}^{N_t-1} (f^n)^2\right)\right)^{1/2} $$

<p>A common approximation of this expression, motivated by the
convenience of having a simpler formula, is
</p>

$$ ||f^n||_{\ell^2} = \left(\Delta t\sum_{n=0}^{N_t} (f^n)^2\right)^{1/2} \tp$$

<p>This is called the discrete \( L^2 \) norm and denoted by \( \ell^2 \).
If \( ||f||_{\ell^2}^2 \) (i.e., the square of the norm) is used
instead of the Trapezoidal integration formula,
the error
is \( \Delta t((f^0)^2 + (f^{N_t})^2)/2 \). This means that the
weights at the end points of the mesh function are perturbed,
but as \( \Delta t\rightarrow 0 \), the error from this perturbation goes
to zero. As long as we are consistent and
stick to one kind of integration
rule for the norm of a mesh function, the details and accuracy of this
rule is of no concern.
</p>

<p>The three discrete norms for a mesh function \( f^n \), corresponding to
the \( L^2 \), \( L^1 \), and \( L^\infty \) norms of \( f(t) \) defined above, are
defined by
</p>

$$
\begin{align}
||f^n||_{\ell^2} &= \left( \Delta t\sum_{n=0}^{N_t} (f^n)^2\right)^{1/2},
\tag{51}\\ 
||f^n||_{\ell^1} &= \Delta t\sum_{n=0}^{N_t} |f^n|,
\tag{52}\\ 
||f^n||_{\ell^\infty} &= \max_{0\leq n\leq N_t}|f^n|\tp
\tag{53}
\end{align}
$$

<p>Note that the \( L^2 \), \( L^1 \), \( \ell^2 \), and \( \ell^1 \) norms depend on the
length of the interval of interest (think of \( f=1 \), then the
norms are proportional to \( \sqrt{T} \) or \( T \)). In some applications it
is convenient to think of a mesh function as just a vector of function
values without any relation to the interval \( [0,T] \).
Then one can replace \( \Delta t \) by \( T/N_t \) and simply drop \( T \) (which
is just a common scaling factor in the norm,
independent of the vector of function
values). Moreover, people prefer
to divide by the total length of the vector, \( N_t+1 \), instead of \( N_t \).
This reasoning gives rise to the <em>vector norms</em> for a vector
\( f=(f_0,\ldots,f_{N}) \):
</p>

$$
\begin{align}
||f||_2 &= \left( \frac{1}{N+1}\sum_{n=0}^{N} (f_n)^2\right)^{1/2},
\tag{54}\\ 
||f||_1 &= \frac{1}{N+1}\sum_{n=0}^{N} |f_n|,
\tag{55}\\ 
||f||_{\ell^\infty} &= \max_{0\leq n\leq N}|f_n|\tp
\tag{56}
\end{align}
$$

<p>Here we have used the common vector component notation with subscripts
(\( f_n \)) and \( N \) as length. We will mostly work with mesh functions
and use the discrete \( \ell^2 \)
norm <a href="#mjx-eqn-51">(51)</a> or the max norm \( \ell^\infty \)
<a href="#mjx-eqn-53">(53)</a>, but the corresponding vector norms
<a href="#mjx-eqn-54">(54)</a>-<a href="#mjx-eqn-56">(56)</a> are also much used
in numerical computations, so it is important to know the different
norms and the relations between them.
</p>

<p>A single number that expresses the size of the numerical error
will be taken as \( ||e^n||_{\ell^2} \) and called \( E \):
</p>

$$
\begin{equation}
E = \sqrt{\Delta t\sum_{n=0}^{N_t} (e^n)^2}
\tag{57}
\end{equation}
$$

<p>The corresponding Python code, using array arithmetics, reads</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">E <span style="color: #666666">=</span> sqrt(dt<span style="color: #666666">*</span><span style="color: #008000">sum</span>(e<span style="color: #666666">**2</span>))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The <code>sum</code> function comes from <code>numpy</code> and computes the sum of the elements
of an array. Also the <code>sqrt</code> function is from <code>numpy</code> and computes the
square root of each element in the array argument.
</p>
<h3 id="scalar-computing" class="anchor">Scalar computing </h3>

<p>Instead of doing array computing <code>sqrt(dt*sum(e**2))</code> we can compute with
one element at a time:
</p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">m <span style="color: #666666">=</span> <span style="color: #008000">len</span>(u)     <span style="color: #3D7B7B; font-style: italic"># length of u array (alt: u.size)</span>
u_e <span style="color: #666666">=</span> zeros(m)
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m):
    u_e[i] <span style="color: #666666">=</span> u_exact(t, a, I)
    t <span style="color: #666666">=</span> t <span style="color: #666666">+</span> dt
e <span style="color: #666666">=</span> zeros(m)
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m):
    e[i] <span style="color: #666666">=</span> u_e[i] <span style="color: #666666">-</span> u[i]
s <span style="color: #666666">=</span> <span style="color: #666666">0</span>  <span style="color: #3D7B7B; font-style: italic"># summation variable</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m):
    s <span style="color: #666666">=</span> s <span style="color: #666666">+</span> e[i]<span style="color: #666666">**2</span>
error <span style="color: #666666">=</span> sqrt(dt<span style="color: #666666">*</span>s)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Such element-wise computing, often called <em>scalar</em> computing, takes
more code, is less readable, and runs much slower than what we
can achieve with array computing.
</p>
<h2 id="experiments-with-computing-and-plotting" class="anchor">Experiments with computing and plotting </h2>

<p>Let us write down a new function that wraps up the computation and all
the plotting statements used for comparing the exact and numerical
solutions. This function can be called with various \( \theta \) and
\( \Delta t \) values to see how the error depends on the method and mesh
resolution.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">explore</span>(I, a, T, dt, theta<span style="color: #666666">=0.5</span>, makeplot<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Run a case with the solver, compute error measure,</span>
<span style="color: #BA2121; font-style: italic">    and plot the numerical and exact solutions (if makeplot=True).</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    u, t <span style="color: #666666">=</span> solver(I, a, T, dt, theta)    <span style="color: #3D7B7B; font-style: italic"># Numerical solution</span>
    u_e <span style="color: #666666">=</span> u_exact(t, I, a)
    e <span style="color: #666666">=</span> u_e <span style="color: #666666">-</span> u
    E <span style="color: #666666">=</span> sqrt(dt<span style="color: #666666">*</span><span style="color: #008000">sum</span>(e<span style="color: #666666">**2</span>))
    <span style="color: #008000; font-weight: bold">if</span> makeplot:
        figure()                         <span style="color: #3D7B7B; font-style: italic"># create new plot</span>
        t_e <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, <span style="color: #666666">1001</span>)       <span style="color: #3D7B7B; font-style: italic"># fine mesh for u_e</span>
        u_e <span style="color: #666666">=</span> u_exact(t_e, I, a)
        plot(t,   u,   <span style="color: #BA2121">&#39;r--o&#39;</span>)           <span style="color: #3D7B7B; font-style: italic"># red dashes w/circles</span>
        plot(t_e, u_e, <span style="color: #BA2121">&#39;b-&#39;</span>)             <span style="color: #3D7B7B; font-style: italic"># blue line for exact sol.</span>
        legend([<span style="color: #BA2121">&#39;numerical&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>])
        xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
        title(<span style="color: #BA2121">&#39;theta=</span><span style="color: #A45A77; font-weight: bold">%g</span><span style="color: #BA2121">, dt=</span><span style="color: #A45A77; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (theta, dt))
        theta2name <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: <span style="color: #BA2121">&#39;FE&#39;</span>, <span style="color: #666666">1</span>: <span style="color: #BA2121">&#39;BE&#39;</span>, <span style="color: #666666">0.5</span>: <span style="color: #BA2121">&#39;CN&#39;</span>}
        savefig(<span style="color: #BA2121">&#39;</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">_</span><span style="color: #A45A77; font-weight: bold">%g</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> (theta2name[theta], dt))
        savefig(<span style="color: #BA2121">&#39;</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">_</span><span style="color: #A45A77; font-weight: bold">%g</span><span style="color: #BA2121">.pdf&#39;</span> <span style="color: #666666">%</span> (theta2name[theta], dt))
        show()
    <span style="color: #008000; font-weight: bold">return</span> E
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The <code>figure()</code> call is key: without it, a new <code>plot</code> command will
draw the new pair of curves in the same plot window, while we want
the different pairs to appear in separate windows and files.
Calling <code>figure()</code> ensures this.
</p>

<p>Instead of including the \( \theta \) value in the filename to implicitly
inform about the applied method, the code utilizes a little Python
dictionary that maps each relevant \( \theta \) value to a corresponding
acronym for the method name (FE, BE, or CN):
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">theta2name <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: <span style="color: #BA2121">&#39;FE&#39;</span>, <span style="color: #666666">1</span>: <span style="color: #BA2121">&#39;BE&#39;</span>, <span style="color: #666666">0.5</span>: <span style="color: #BA2121">&#39;CN&#39;</span>}
savefig(<span style="color: #BA2121">&#39;</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">_</span><span style="color: #A45A77; font-weight: bold">%g</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> (theta2name[theta], dt))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The <code>explore</code> function stores the plot in two different image file formats:
PNG and PDF. The PNG format is suitable for
being included in HTML documents, while the PDF format provides
higher quality for LaTeX (i.e., pdfLaTeX) documents.
Frequently used viewers for these
image files on Unix systems are <code>gv</code> (comes with Ghostscript)
for the PDF format and
<code>display</code> (from the ImageMagick software suite) for PNG files:
</p>


<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">Terminal&gt; gv BE_0.5.pdf
Terminal&gt; display BE_0.5.png
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>A main program may run a loop over the three methods (given by
their corresponding \( \theta \) values)
and call <code>explore</code> to compute errors and make plots:
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>(I, a, T, dt_values, theta_values<span style="color: #666666">=</span>(<span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>)):
    <span style="color: #008000">print</span> <span style="color: #BA2121">&#39;theta   dt       error&#39;</span>  <span style="color: #3D7B7B; font-style: italic"># Column headings in table</span>
    <span style="color: #008000; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> theta_values:
        <span style="color: #008000; font-weight: bold">for</span> dt <span style="color: #AA22FF; font-weight: bold">in</span> dt_values:
            E <span style="color: #666666">=</span> explore(I, a, T, dt, theta, makeplot<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
            <span style="color: #008000">print</span> <span style="color: #BA2121">&#39;</span><span style="color: #A45A77; font-weight: bold">%4.1f</span><span style="color: #BA2121"> </span><span style="color: #A45A77; font-weight: bold">%6.2f</span><span style="color: #BA2121">: </span><span style="color: #A45A77; font-weight: bold">%12.3E</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (theta, dt, E)

main(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=2</span>, T<span style="color: #666666">=5</span>, dt_values<span style="color: #666666">=</span>[<span style="color: #666666">0.4</span>, <span style="color: #666666">0.04</span>])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The file <a href="http://tinyurl.com/ofkw6kc/alg/decay_plot_mpl.py" target="_self"><tt>decay_plot_mpl.py</tt></a>
contains the complete code with the functions above.
Running this program results in
</p>


<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">Terminal&gt; python decay_plot_mpl.py
theta   dt       error
 0.0   0.40:    2.105E-01
 0.0   0.04:    1.449E-02
 0.5   0.40:    3.362E-02
 0.5   0.04:    1.887E-04
 1.0   0.40:    1.030E-01
 1.0   0.04:    1.382E-02
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We observe that reducing \( \Delta t \) by a factor of 10 increases the
accuracy for all three methods. We also see that
the combination of \( \theta=0.5 \) and a small time step \( \Delta t =0.04 \)
gives a much more accurate solution, and that \( \theta=0 \) and \( \theta=1 \)
with \( \Delta t = 0.4 \) result in the least accurate solutions.
</p>

<p>Figure <a href="#decay:fig:FE1">8</a> demonstrates that the numerical solution
produced by the Forward Euler method with
\( \Delta t=0.4 \) clearly lies below the exact curve, but that the
accuracy improves considerably by reducing the time step by a factor
of 10.
</p>

<center> <!-- figure label: --> <div id="decay:fig:FE1"></div> <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 8: The Forward Euler scheme for two values of the time step.  <!-- caption label: decay:fig:FE1 --></p>
</center>
<p><img src="fig-alg/FE1.png" width="600" align="bottom"></p>
</center>

<p>The behavior of the two other schemes is shown in Figures <a href="#decay:fig:BE1">9</a>
and <a href="#decay:fig:CN1">10</a>. Crank-Nicolson is obviously the most accurate
scheme from this visual point of view.
</p>

<center> <!-- figure label: --> <div id="decay:fig:BE1"></div> <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 9: The Backward Euler scheme for two values of the time step.  <!-- caption label: decay:fig:BE1 --></p>
</center>
<p><img src="fig-alg/BE1.png" width="600" align="bottom"></p>
</center>

<center> <!-- figure label: --> <div id="decay:fig:CN1"></div> <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 10: The Crank-Nicolson scheme for two values of the time step.  <!-- caption label: decay:fig:CN1 --></p>
</center>
<p><img src="fig-alg/CN1.png" width="600" align="bottom"></p>
</center>

<h3 id="combining-plot-files" class="anchor">Combining plot files </h3>

<p>Mounting two PNG files beside each other, as done in Figures
<a href="#decay:fig:FE1">8</a>-<a href="#decay:fig:CN1">10</a>, is easily carried out by the
<a href="http://www.imagemagick.org/script/montage.php" target="_self"><tt>montage</tt></a> program
from the ImageMagick suite:
</p>


<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">Terminal&gt; montage -background white -geometry 100% -tile 2x1 \ 
          FE_0.4.png FE_0.04.png FE1.png
Terminal&gt; convert -trim FE1.png FE1.png
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The <code>-geometry</code> argument is used to specify the size of the image. Here,
we preserve the individual sizes of the images. The <code>-tile HxV</code> option
specifies <code>H</code> images in the horizontal direction and <code>V</code> images in
the vertical direction. A series of image files to be combined are then listed,
with the name of the resulting combined image, here <code>FE1.png</code> at the end.
The <code>convert -trim</code> command removes surrounding white areas in the figure
(an operation usually known as <em>cropping</em> in image manipulation programs).
</p>

<p>For LaTeX reports it is not recommended to use <code>montage</code> and PNG files
as the result has too low resolution. Instead, plots should be made
in the PDF format and combined using the <code>pdftk</code>, <code>pdfnup</code>, and <code>pdfcrop</code> tools
(on Linux/Unix):
</p>


<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">Terminal&gt; pdftk FE_0.4.png FE_0.04.png output tmp.pdf
Terminal&gt; pdfnup --nup 2x1 --outfile tmp.pdf tmp.pdf
Terminal&gt; pdfcrop tmp.pdf FE1.png  # output in FE1.png
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Here, <code>pdftk</code> combines images into a multi-page PDF file, <code>pdfnup</code>
combines the images in individual pages to a table of images (pages),
and <code>pdfcrop</code> removes white margins in the resulting combined image file.
</p>
<h3 id="plotting-with-scitools" class="anchor">Plotting with SciTools </h3>

<p>The <a href="https://github.com/hplgit/scitools" target="_self">SciTools package</a> provides a
unified plotting interface, called Easyviz, to many different plotting
packages, including Matplotlib, Gnuplot, Grace, MATLAB,
VTK, OpenDX, and VisIt. The syntax is very similar to that of
Matplotlib and MATLAB. In fact, the plotting commands shown above look
the same in SciTool's Easyviz interface, apart from the import
statement, which reads
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>This statement performs a <code>from numpy import *</code> as well as an import
of the most common pieces of the Easyviz (<code>scitools.easyviz</code>) package,
along with some additional numerical functionality.
</p>

<p>With Easyviz one can
merge several plotting commands into a single one
using keyword arguments:
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">plot(t,   u,   <span style="color: #BA2121">&#39;r--o&#39;</span>,           <span style="color: #3D7B7B; font-style: italic"># red dashes w/circles</span>
     t_e, u_e, <span style="color: #BA2121">&#39;b-&#39;</span>,             <span style="color: #3D7B7B; font-style: italic"># blue line for exact sol.</span>
     legend<span style="color: #666666">=</span>[<span style="color: #BA2121">&#39;numerical&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>],
     xlabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;t&#39;</span>,
     ylabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;u&#39;</span>,
     title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;theta=</span><span style="color: #A45A77; font-weight: bold">%g</span><span style="color: #BA2121">, dt=</span><span style="color: #A45A77; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (theta, dt),
     savefig<span style="color: #666666">=</span><span style="color: #BA2121">&#39;</span><span style="color: #A45A77; font-weight: bold">%s</span><span style="color: #BA2121">_</span><span style="color: #A45A77; font-weight: bold">%g</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> (theta2name[theta], dt),
     show<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The <a href="http://tinyurl.com/ofkw6kc/alg/decay_plot_st.py" target="_self"><tt>decay_plot_st.py</tt></a> file
contains such a demo.
</p>

<p>By default, Easyviz employs Matplotlib for plotting, but <a href="http://www.gnuplot.info/" target="_self">Gnuplot</a> and <a href="http://plasma-gate.weizmann.ac.il/Grace/" target="_self">Grace</a> are viable alternatives:
</p>


<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">Terminal&gt; python decay_plot_st.py --SCITOOLS_easyviz_backend gnuplot
Terminal&gt; python decay_plot_st.py --SCITOOLS_easyviz_backend grace
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The actual tool used for creating plots (called <em>backend</em>)
and numerous other options
can be permanently set in SciTool's configuration file.
</p>

<p>All the Gnuplot windows are launched without any need to kill one before
the next one pops up (as is the case with Matplotlib) and one can
press the key 'q' anywhere in a plot window to kill it.
Another advantage of Gnuplot is the automatic choice of sensible
and distinguishable line types in black-and-white PDF and PostScript
files.
</p>

<p>For more detailed information on syntax and plotting capabilities,
we refer to the Matplotlib <a href="._alg-sol004.html#Matplotlib:doc">[2]</a>
and SciTools <a href="._alg-sol004.html#SciTools:doc">[3]</a> documentation.
The hope is that
the programming syntax explained so far suffices for understanding the
basic plotting functionality and being able to look up
the cited technical documentation.
</p>
<h2 id="memory-saving-implementation" class="anchor">Memory-saving implementation </h2>

<p>The computer memory requirements of our implementations so far consist
mainly of the <code>u</code> and <code>t</code> arrays, both of length \( N_t+1 \).  Also, for
the programs that involve array arithmetics, Python needs memory space
for storing temporary arrays. For example, computing <code>I*exp(-a*t)</code>
requires storing the intermediate result <code>a*t</code> before the preceding
minus sign can be applied. The resulting array is temporarily stored
and provided as input to the <code>exp</code> function.  Regardless of how we
implement simple ODE problems, storage requirements are very modest
and put no restrictions on how we choose our data structures and
algorithms.  Nevertheless, when the presented methods are applied to
three-dimensional PDE problems, memory storage requirements suddenly
become a challenging issue.
</p>

<p>Let us briefly elaborate on how large the storage requirements can
quickly be in three-dimensional problems.  The PDE counterpart to our
model problem \( u'=-a \) is a diffusion equation \( u_t = a\nabla^2 u \)
posed on a space-time domain. The discrete representation of this
domain may in 3D be a spatial mesh of \( M^3 \) points and a time mesh of
\( N_t \) points.  In many applications, it is quite typical that \( M \) is
at least 100, or even 1000.  Storing all the computed \( u \) values, like
we have done in the programs so far, would demand storing arrays of
size up to \( M^3N_t \). This would give a factor of \( M^3 \) larger storage
demands compared to what was required by our ODE programs. Each real
number in the <code>u</code> array requires 8 bytes (b) of storage. With \( M=100 \)
and \( N_t=1000 \), there is a storage demand of \( (10^3)^3\cdot 1000\cdot
8 = 8 \) Gb for the solution array.  Fortunately, we can usually get rid
of the \( N_t \) factor, resulting in 8 Mb of storage.  Below we explain
how this is done (the technique is almost always applied in
implementations of PDE problems).
</p>

<p>Let us critically evaluate how much we really need to store in the
computer's memory for our implementation of the \( \theta \) method. To
compute a new \( u^{n+1} \), all we need is \( u^n \). This implies that the
previous \( u^{n-1},u^{n-2},\dots,u^0 \) values do not need to be stored,
although this is convenient for plotting and data analysis in the
program.  Instead of the <code>u</code> array we can work with two variables for
real numbers, <code>u</code> and <code>u_1</code>, representing \( u^{n+1} \) and \( u^n \) in the
algorithm, respectively.  At each time level, we update <code>u</code> from <code>u_1</code>
and then set <code>u_1 = u</code>, so that the computed \( u^{n+1} \) value becomes
the "previous" value \( u^n \) at the next time level. The downside is
that we cannot plot the solution after the simulation is done since
only the last two numbers are available.  The remedy is to store
computed values in a file and use the file for visualizing the
solution later.
</p>

<p>We have implemented this memory saving idea in the file
<a href="http://tinyurl.com/ofkw6kc/alg/decay_memsave.py" target="_self"><tt>decay_memsave.py</tt></a>, which is a
slight modification of <a href="http://tinyurl.com/ofkw6kc/alg/decay_plot_mpl.py" target="_self"><tt>decay_plot_mpl.py</tt></a> program.
</p>

<p>The following function demonstrates how we work with the two most
recent values of the unknown:
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_memsave</span>(I, a, T, dt, theta, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;sol.dat&#39;</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.</span>
<span style="color: #BA2121; font-style: italic">    Minimum use of memory. The solution is stored in a file</span>
<span style="color: #BA2121; font-style: italic">    (with name filename) for later plotting.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)         <span style="color: #3D7B7B; font-style: italic"># avoid integer division</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))  <span style="color: #3D7B7B; font-style: italic"># no of intervals</span>

    outfile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;w&#39;</span>)
    <span style="color: #3D7B7B; font-style: italic"># u: time level n+1, u_1: time level n</span>
    t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    u_1 <span style="color: #666666">=</span> I
    outfile<span style="color: #666666">.</span>write(<span style="color: #BA2121">&#39;</span><span style="color: #A45A77; font-weight: bold">%.16E</span><span style="color: #BA2121">  </span><span style="color: #A45A77; font-weight: bold">%.16E</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t, u_1))
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nt<span style="color: #666666">+1</span>):
        u <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)<span style="color: #666666">*</span>u_1
        u_1 <span style="color: #666666">=</span> u
        t <span style="color: #666666">+=</span> dt
        outfile<span style="color: #666666">.</span>write(<span style="color: #BA2121">&#39;</span><span style="color: #A45A77; font-weight: bold">%.16E</span><span style="color: #BA2121">  </span><span style="color: #A45A77; font-weight: bold">%.16E</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t, u))
    outfile<span style="color: #666666">.</span>close()
    <span style="color: #008000; font-weight: bold">return</span> u, t
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>This code snippet also serves as a quick introduction to file writing in Python.
Reading the data in the file into arrays <code>t</code> and <code>u</code> is done by the
function
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_file</span>(filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;sol.dat&#39;</span>):
    infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;r&#39;</span>)
    u <span style="color: #666666">=</span> [];  t <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> infile:
        words <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(words) <span style="color: #666666">!=</span> <span style="color: #666666">2</span>:
            <span style="color: #008000">print</span> <span style="color: #BA2121">&#39;Found more than two numbers on a line!&#39;</span>, words
            sys<span style="color: #666666">.</span>exit(<span style="color: #666666">1</span>)  <span style="color: #3D7B7B; font-style: italic"># abort</span>
        t<span style="color: #666666">.</span>append(<span style="color: #008000">float</span>(words[<span style="color: #666666">0</span>]))
        u<span style="color: #666666">.</span>append(<span style="color: #008000">float</span>(words[<span style="color: #666666">1</span>]))
    <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>array(t), np<span style="color: #666666">.</span>array(u)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>This type of file with numbers in rows and columns is very common, and
<code>numpy</code> has a function <code>loadtxt</code> which loads such tabular data into a
two-dimensional array named by the user. Say the name is <code>data</code>, the
number in row <code>i</code> and column <code>j</code> is then <code>data[i,j]</code>.  The whole
column number <code>j</code> can be extracted by <code>data[:,j]</code>.  A version of
<code>read_file</code> using <code>np.loadtxt</code> reads
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_file_numpy</span>(filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;sol.dat&#39;</span>):
    data <span style="color: #666666">=</span> np<span style="color: #666666">.</span>loadtxt(filename)
    t <span style="color: #666666">=</span> data[:,<span style="color: #666666">0</span>]
    u <span style="color: #666666">=</span> data[:,<span style="color: #666666">1</span>]
    <span style="color: #008000; font-weight: bold">return</span> t, u
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The present counterpart to the <code>explore</code> function from
<a href="http://tinyurl.com/ofkw6kc/alg/decay_plot_mpl.py" target="_self"><tt>decay_plot_mpl.py</tt></a> must run
<code>solver_memsave</code> and then load data from file before we can compute
the error measure and make the plot:
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">explore</span>(I, a, T, dt, theta<span style="color: #666666">=0.5</span>, makeplot<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>):
    filename <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;u.dat&#39;</span>
    u, t <span style="color: #666666">=</span> solver_memsave(I, a, T, dt, theta, filename)

    t, u <span style="color: #666666">=</span> read_file(filename)
    u_e <span style="color: #666666">=</span> u_exact(t, I, a)
    e <span style="color: #666666">=</span> u_e <span style="color: #666666">-</span> u
    E <span style="color: #666666">=</span> sqrt(dt<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sum(e<span style="color: #666666">**2</span>))
    <span style="color: #008000; font-weight: bold">if</span> makeplot:
        figure()
        <span style="color: #666666">...</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Apart from the internal implementation, where \( u^n \) values are stored
in a file rather than in an array, <code>decay_memsave.py</code> file works
exactly as the <code>decay_plot_mpl.py</code> file.
</p>

<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._alg-sol001.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._alg-sol003.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->
</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<!-- Bootstrap footer
<footer>
<a href="https://..."><img width="250" align=right src="https://..."></a>
</footer>
-->
</body>
</html>

