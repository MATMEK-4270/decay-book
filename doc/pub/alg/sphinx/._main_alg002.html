

<!DOCTYPE html>

<html lang="1.0">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Implementations &#8212; _ Hans Petter Langtangen documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/default.css" />
    <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/sidebar.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Exercises" href="._main_alg003.html" />
    <link rel="prev" title="Finite difference methods" href="._main_alg001.html" /> 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_alg003.html" title="Exercises"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._main_alg001.html" title="Finite difference methods"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">_ Hans Petter Langtangen documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Implementations</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="implementations">
<span id="decay-impl1"></span><h1>Implementations<a class="headerlink" href="#implementations" title="Permalink to this headline">¶</a></h1>
<p>We want to make a computer program for solving</p>
<div class="math notranslate nohighlight">
\[u^{\prime}(t) = -au(t),\quad t\in (0,T], \quad u(0)=I,\]</div>
<p>by finite difference methods. The program should also display
the numerical solution as a curve on the
screen, preferably together with the
exact solution.</p>
<span class="target" id="index-0"></span><p id="index-1">All programs referred to in this section are found in the
<a class="reference external" href="http://tinyurl.com/ofkw6kc/alg">src/alg</a> directory (we use the classical
Unix term <em>directory</em> for what many others nowadays call <em>folder</em>).</p>
<p><strong>Mathematical problem.</strong>
We want to explore the Forward Euler scheme, the
Backward Euler, and the Crank-Nicolson schemes applied to our model problem.
From an implementational point of view, it is advantageous to
implement the <span class="math notranslate nohighlight">\(\theta\)</span>-rule</p>
<div class="math notranslate nohighlight">
\[u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,\]</div>
<p>since it can generate the three other schemes by various
choices of <span class="math notranslate nohighlight">\(\theta\)</span>: <span class="math notranslate nohighlight">\(\theta=0\)</span> for Forward Euler, <span class="math notranslate nohighlight">\(\theta =1\)</span> for
Backward Euler, and <span class="math notranslate nohighlight">\(\theta =1/2\)</span> for Crank-Nicolson.
Given <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(u^0=I\)</span>, <span class="math notranslate nohighlight">\(T\)</span>, and <span class="math notranslate nohighlight">\(\Delta t\)</span>,
our task is to use the <span class="math notranslate nohighlight">\(\theta\)</span>-rule to
compute <span class="math notranslate nohighlight">\(u^1, u^2,\ldots,u^{N_t}\)</span>, where <span class="math notranslate nohighlight">\(t_{N_t}=N_t\Delta t\)</span>, and
<span class="math notranslate nohighlight">\(N_t\)</span> the closest integer to <span class="math notranslate nohighlight">\(T/\Delta t\)</span>.</p>
<section id="computer-language-python">
<h2>Computer language: Python<a class="headerlink" href="#computer-language-python" title="Permalink to this headline">¶</a></h2>
<p>Any programming language can be used to generate the <span class="math notranslate nohighlight">\(u^{n+1}\)</span> values from
the formula above. However, in this document we shall mainly make use of
Python. There are several good reasons for this choice:</p>
<blockquote>
<div><ul class="simple">
<li><p>Python has a very clean, readable syntax (often known as &quot;executable pseudo-code&quot;).</p></li>
<li><p>Python code is very similar to MATLAB code (and MATLAB has a particularly widespread use for scientific computing).</p></li>
<li><p>Python is a full-fledged, very powerful programming language.</p></li>
<li><p>Python is similar to C++, but is much simpler to work with and results in more reliable code.</p></li>
<li><p>Python has a rich set of modules for scientific computing, and its popularity in scientific computing is rapidly growing.</p></li>
<li><p>Python was made for being combined with compiled languages (C, C++, Fortran), so that existing numerical software can be reused, and thereby easing high computational performance with new implementations.</p></li>
<li><p>Python has extensive support for administrative tasks needed when doing large-scale computational investigations.</p></li>
<li><p>Python has extensive support for graphics (visualization, user interfaces, web applications).</p></li>
</ul>
</div></blockquote>
<p>Learning Python is easy. Many newcomers to the language will probably
learn enough from the forthcoming examples to perform their own computer
experiments. The examples start with simple Python code and gradually
make use of more powerful constructs as we proceed. Unless it is
inconvenient for the problem at hand, our Python code is made as
close as possible to MATLAB code for easy transition between the two
languages.</p>
<p>The coming programming examples assumes familiarity with
variables, for loops, lists, arrays,
functions, positional arguments, and keyword (named) arguments.
A background in basic MATLAB programming is often enough to understand
Python examples.
Readers who feel the Python examples are too hard to follow will
benefit from reading a tutorial, e.g.,</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="http://docs.python.org/2/tutorial/">The Official Python Tutorial</a></p></li>
<li><p><a class="reference external" href="http://www.tutorialspoint.com/python/">Python Tutorial on tutorialspoint.com</a></p></li>
<li><p><a class="reference external" href="http://www.learnpython.org/">Interactive Python tutorial site</a></p></li>
<li><p><a class="reference external" href="http://en.wikibooks.org/wiki/A_Beginner's_Python_Tutorial">A Beginner's Python Tutorial</a></p></li>
</ul>
</div></blockquote>
<p>The author also has a comprehensive book <a class="reference internal" href="._main_alg004.html#ref1" id="id1"><span>[Ref1]</span></a> that teaches
scientific programming with Python from the ground up.</p>
</section>
<section id="making-a-solver-function">
<span id="decay-py1"></span><h2>Making a solver function<a class="headerlink" href="#making-a-solver-function" title="Permalink to this headline">¶</a></h2>
<p>We choose to have an array <code class="docutils literal notranslate"><span class="pre">u</span></code> for storing the <span class="math notranslate nohighlight">\(u^n\)</span> values, <span class="math notranslate nohighlight">\(n=0,1,\ldots,N_t\)</span>.
The algorithmic steps are</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>initialize <span class="math notranslate nohighlight">\(u^0\)</span></p></li>
<li><p>for <span class="math notranslate nohighlight">\(t=t_n\)</span>, <span class="math notranslate nohighlight">\(n=1,2,\ldots,N_t\)</span>: compute <span class="math notranslate nohighlight">\(u_n\)</span> using the <span class="math notranslate nohighlight">\(\theta\)</span>-rule formula</p></li>
</ol>
</div></blockquote>
<p>An implementation of a numerical algorithm is often referred to as
a <em>solver</em>. We shall now make a solver for our model problem and
realize the solver as a Python function. The function must take
the input data <span class="math notranslate nohighlight">\(I\)</span>, <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(T\)</span>, <span class="math notranslate nohighlight">\(\Delta t\)</span>, and <span class="math notranslate nohighlight">\(\theta\)</span> of the problem
as arguments and return the solution as arrays <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> for
<span class="math notranslate nohighlight">\(u^n\)</span> and <span class="math notranslate nohighlight">\(t^n\)</span>, <span class="math notranslate nohighlight">\(n=0,\ldots,N_t\)</span>. The solver function used as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
</pre></div>
</div>
<p>One can now easily plot <code class="docutils literal notranslate"><span class="pre">u</span></code> versus <code class="docutils literal notranslate"><span class="pre">t</span></code> to visualize the solution.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">solver</span></code> may look as follows in Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>            <span class="c1"># no of time intervals</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>                 <span class="c1"># adjust T to fit time step dt</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c1"># array of u[n] values</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># time mesh</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>                  <span class="c1"># assign initial condition</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>    <span class="c1"># n=0,1,...,Nt-1</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">numpy</span></code> library contains a lot of functions for array computing. Most
of the function names are similar to what is found
in the alternative scientific computing language MATLAB. Here
we make use of</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">zeros(Nt+1)</span></code> for creating an array of size <code class="docutils literal notranslate"><span class="pre">Nt+1</span></code> and initializing the elements to zero</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">linspace(0,</span> <span class="pre">T,</span> <span class="pre">Nt+1)</span></code> for creating an array with <code class="docutils literal notranslate"><span class="pre">Nt+1</span></code> coordinates uniformly distributed between <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">for</span></code> loop deserves a comment, especially for newcomers to Python.
The construction <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">Nt,</span> <span class="pre">s)</span></code> generates all integers from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">Nt</span></code>
in steps of <code class="docutils literal notranslate"><span class="pre">s</span></code>, <em>but not including</em> <code class="docutils literal notranslate"><span class="pre">Nt</span></code>. Omitting <code class="docutils literal notranslate"><span class="pre">s</span></code> means <code class="docutils literal notranslate"><span class="pre">s=1</span></code>.
For example, <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">6,</span> <span class="pre">3)</span></code>
gives <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">3</span></code>, while <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">6)</span></code> generates
the list <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5]</span></code>.
Our loop implies the following assignments to <code class="docutils literal notranslate"><span class="pre">u[n+1]</span></code>: <code class="docutils literal notranslate"><span class="pre">u[1]</span></code>, <code class="docutils literal notranslate"><span class="pre">u[2]</span></code>, ...,
<code class="docutils literal notranslate"><span class="pre">u[Nt]</span></code>, which is what we want since <code class="docutils literal notranslate"><span class="pre">u</span></code> has length <code class="docutils literal notranslate"><span class="pre">Nt+1</span></code>.
The first index in Python arrays or lists is <em>always</em> <code class="docutils literal notranslate"><span class="pre">0</span></code> and the
last is then <code class="docutils literal notranslate"><span class="pre">len(u)-1</span></code> (the length of an array <code class="docutils literal notranslate"><span class="pre">u</span></code> is obtained by
<code class="docutils literal notranslate"><span class="pre">len(u)</span></code> or <code class="docutils literal notranslate"><span class="pre">u.size</span></code>).</p>
</section>
<section id="integer-division">
<span id="decay-py2"></span><h2>Integer division<a class="headerlink" href="#integer-division" title="Permalink to this headline">¶</a></h2>
<p>The shown implementation of the <code class="docutils literal notranslate"><span class="pre">solver</span></code> may face problems and
wrong results if <code class="docutils literal notranslate"><span class="pre">T</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">dt</span></code>, and <code class="docutils literal notranslate"><span class="pre">theta</span></code> are given as integers
(see <a class="reference internal" href="._main_alg003.html#decay-exer-intdiv"><span class="std std-ref">Problem 3: Experiment with divisions</span></a> and <a class="reference internal" href="._main_alg003.html#decay-exer-decay1err"><span class="std std-ref">Problem 4: Experiment with wrong computations</span></a>).
The problem is related to <em>integer division</em> in Python (as
in Fortran, C, C++, and many other computer languages!): <code class="docutils literal notranslate"><span class="pre">1/2</span></code> becomes <code class="docutils literal notranslate"><span class="pre">0</span></code>,
while <code class="docutils literal notranslate"><span class="pre">1.0/2</span></code>, <code class="docutils literal notranslate"><span class="pre">1/2.0</span></code>, or <code class="docutils literal notranslate"><span class="pre">1.0/2.0</span></code> all become <code class="docutils literal notranslate"><span class="pre">0.5</span></code>. So, it is enough
that at least the nominator or the denominator is a real number
(i.e., a <code class="docutils literal notranslate"><span class="pre">float</span></code> object)
to ensure a correct mathematical division. Inserting
a conversion <code class="docutils literal notranslate"><span class="pre">dt</span> <span class="pre">=</span> <span class="pre">float(dt)</span></code>
guarantees that <code class="docutils literal notranslate"><span class="pre">dt</span></code> is
<code class="docutils literal notranslate"><span class="pre">float</span></code>.</p>
<p>Another problem with computing <span class="math notranslate nohighlight">\(N_t=T/\Delta t\)</span> is that we should
round <span class="math notranslate nohighlight">\(N_t\)</span> to the nearest integer. With <code class="docutils literal notranslate"><span class="pre">Nt</span> <span class="pre">=</span> <span class="pre">int(T/dt)</span></code> the <code class="docutils literal notranslate"><span class="pre">int</span></code>
operation picks the largest integer smaller than <code class="docutils literal notranslate"><span class="pre">T/dt</span></code>. Correct
mathematical rounding as known from school is obtained by</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
</pre></div>
</div>
<p>The complete version of our improved, safer <code class="docutils literal notranslate"><span class="pre">solver</span></code> function then becomes</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>            <span class="c1"># avoid integer division</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>     <span class="c1"># no of time intervals</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>                 <span class="c1"># adjust T to fit time step dt</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c1"># array of u[n] values</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># time mesh</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>                  <span class="c1"># assign initial condition</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>    <span class="c1"># n=0,1,...,Nt-1</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
</section>
<section id="doc-strings">
<h2>Doc strings<a class="headerlink" href="#doc-strings" title="Permalink to this headline">¶</a></h2>
<p id="index-2">Right below the header line in the <code class="docutils literal notranslate"><span class="pre">solver</span></code> function there is a
Python string enclosed in triple double quotes <code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;</span></code>.
The purpose of this string object is to document what the function
does and what the arguments are. In this case the necessary
documentation does not span more than one line, but with triple double
quoted strings the text may span several lines:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve</span>

<span class="sd">        u&#39;(t) = -a*u(t),</span>

<span class="sd">    with initial condition u(0)=I, for t in the time interval</span>
<span class="sd">    (0,T]. The time interval is divided into time steps of</span>
<span class="sd">    length dt.</span>

<span class="sd">    theta=1 corresponds to the Backward Euler scheme, theta=0</span>
<span class="sd">    to the Forward Euler scheme, and theta=0.5 to the Crank-</span>
<span class="sd">    Nicolson method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Such documentation strings appearing right after the header of
a function are called <em>doc strings</em>. There are tools that can automatically
produce nicely formatted documentation by extracting the definition of
functions and the contents of doc strings.</p>
<p>It is strongly recommended to equip any function with a doc string,
unless the purpose of the function
is not obvious. Nevertheless, the forthcoming
text deviates from this rule if the function is explained in the text.</p>
</section>
<section id="formatting-numbers">
<h2>Formatting numbers<a class="headerlink" href="#formatting-numbers" title="Permalink to this headline">¶</a></h2>
<p>Having computed the discrete solution <code class="docutils literal notranslate"><span class="pre">u</span></code>, it is natural to look at
the numbers:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Write out a table of t and u values:</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
    <span class="nb">print</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>This compact <code class="docutils literal notranslate"><span class="pre">print</span></code> statement unfortunately gives less readable output
because the <code class="docutils literal notranslate"><span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">u</span></code> values are not aligned in nicely formatted columns.
To fix this problem, we recommend to use the <em>printf format</em>, supported in most
programming languages inherited from C. Another choice is
Python's recent <em>format string syntax</em>. Both kinds of syntax are illustrated
below.</p>
<p id="index-3">Writing <code class="docutils literal notranslate"><span class="pre">t[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">u[i]</span></code> in two nicely formatted columns is done like
this with the printf format:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="s1">&#39;t=</span><span class="si">%6.3f</span><span class="s1"> u=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>The percentage signs signify &quot;slots&quot; in the text where the variables
listed at the end of the statement are inserted. For each &quot;slot&quot; one
must specify a format for how the variable is going to appear in the
string: <code class="docutils literal notranslate"><span class="pre">f</span></code> for float (with 6 decimals),
<code class="docutils literal notranslate"><span class="pre">s</span></code> for pure text, <code class="docutils literal notranslate"><span class="pre">d</span></code> for an integer, <code class="docutils literal notranslate"><span class="pre">g</span></code> for a real number
written as compactly as possible, <code class="docutils literal notranslate"><span class="pre">9.3E</span></code> for scientific notation with
three decimals in a field of width 9 characters (e.g., <code class="docutils literal notranslate"><span class="pre">-1.351E-2</span></code>),
or <code class="docutils literal notranslate"><span class="pre">.2f</span></code> for standard decimal notation with two decimals
formatted with minimum width. The printf syntax provides a quick way
of formatting tabular output of numbers with full control of the
layout.</p>
<p id="index-4">The alternative <em>format string syntax</em> looks like</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="s1">&#39;t=</span><span class="si">{t:6.3f}</span><span class="s1"> u=</span><span class="si">{u:g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>As seen, this format allows logical names in the &quot;slots&quot; where
<code class="docutils literal notranslate"><span class="pre">t[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">u[i]</span></code> are to be inserted. The &quot;slots&quot; are surrounded
by curly braces, and the logical name is followed by a colon and
then the printf-like specification of how to format real numbers,
integers, or strings.</p>
</section>
<section id="running-the-program">
<h2>Running the program<a class="headerlink" href="#running-the-program" title="Permalink to this headline">¶</a></h2>
<p>The function and main program shown above must be placed in a file,
say with name <a class="reference external" href="http://tinyurl.com/ofkw6kc/alg/decay_v1.py">decay_v1.py</a> (<code class="docutils literal notranslate"><span class="pre">v1</span></code> for 1st version of this program).  Make sure you
write the code with a suitable text editor (Gedit, Emacs, Vim,
Notepad++, or similar).  The program is run by executing the file this
way:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Terminal&gt; python decay_v1.py
</pre></div>
</div>
<p>The text <code class="docutils literal notranslate"><span class="pre">Terminal&gt;</span></code> just indicates a prompt in a
Unix/Linux or DOS terminal window. After this prompt, which may look
different in your terminal window (depending on the terminal application
and how it is set up), commands like <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">decay_v1.py</span></code> can be issued.
These commands are interpreted by the operating system.</p>
<p>We strongly recommend to run Python programs within the IPython shell.
First start IPython by typing <code class="docutils literal notranslate"><span class="pre">ipython</span></code> in the terminal window.
Inside the IPython shell, our program <code class="docutils literal notranslate"><span class="pre">decay_v1.py</span></code> is run by the command
<code class="docutils literal notranslate"><span class="pre">run</span> <span class="pre">decay_v1.py</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Terminal&gt; ipython

In [1]: run decay_v1.py
t= 0.000 u=1
t= 0.800 u=0.384615
t= 1.600 u=0.147929
t= 2.400 u=0.0568958
t= 3.200 u=0.021883
t= 4.000 u=0.00841653
t= 4.800 u=0.00323713
t= 5.600 u=0.00124505
t= 6.400 u=0.000478865
t= 7.200 u=0.000184179
t= 8.000 u=7.0838e-05
</pre></div>
</div>
<p>The advantage of running programs in IPython are many, but here
we explicitly mention a few of the most
useful features:</p>
<blockquote>
<div><ul class="simple">
<li><p>previous commands are easily recalled with the up arrow,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%pdb</span></code> turns on a debugger so that variables can be examined if the program aborts (due to a Python exception),</p></li>
<li><p>output of commands are stored in variables,</p></li>
<li><p>the computing time spent on a set of statements can be measured with the <code class="docutils literal notranslate"><span class="pre">%timeit</span></code> command,</p></li>
<li><p>any operating system command can be executed,</p></li>
<li><p>modules can be loaded automatically and other customizations can be performed when starting IPython</p></li>
</ul>
</div></blockquote>
<p>Although running programs in IPython is strongly recommended, most
execution examples in the forthcoming text use the standard
Python shell with prompt <code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code> and run programs through
a typesetting like</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Terminal&gt; python programname
</pre></div>
</div>
<p>The reason is that such typesetting
makes the text more compact in the vertical direction
than showing sessions with IPython syntax.</p>
<span class="target" id="index-5"></span></section>
<section id="plotting-the-solution">
<span id="index-6"></span><h2>Plotting the solution<a class="headerlink" href="#plotting-the-solution" title="Permalink to this headline">¶</a></h2>
<p>Having the <code class="docutils literal notranslate"><span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">u</span></code> arrays, the approximate solution <code class="docutils literal notranslate"><span class="pre">u</span></code> is visualized
by the intuitive command <code class="docutils literal notranslate"><span class="pre">plot(t,</span> <span class="pre">u)</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>It will be illustrative to also plot the exact solution
<span class="math notranslate nohighlight">\({u_{\small\mbox{e}}}(t)=Ie^{-at}\)</span> for comparison. We first
need to make a Python function for computing the exact solution:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>It is tempting to just do</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">u_e</span><span class="p">)</span>
</pre></div>
</div>
<p>However, this is not exactly what we want: the <code class="docutils literal notranslate"><span class="pre">plot</span></code> function draws
straight lines between the discrete points <code class="docutils literal notranslate"><span class="pre">(t[n],</span> <span class="pre">u_e[n])</span></code> while
<span class="math notranslate nohighlight">\({u_{\small\mbox{e}}}(t)\)</span> varies as an exponential function between the mesh points.
The technique for showing the &quot;exact&quot; variation of <span class="math notranslate nohighlight">\({u_{\small\mbox{e}}}(t)\)</span> between
the mesh points is to introduce a very fine mesh for <span class="math notranslate nohighlight">\({u_{\small\mbox{e}}}(t)\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>      <span class="c1"># fine mesh</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>We can also plot the curves with different colors and styles, e.g.,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span>         <span class="c1"># blue line for u_e</span>
     <span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s1">&#39;r--o&#39;</span><span class="p">)</span>       <span class="c1"># red dashes w/circles</span>
</pre></div>
</div>
<p>With more than one curve in the plot we need to associate each curve
with a legend. We also want appropriate names on the axes, a title,
and a file containing the plot as an image for inclusion in reports.
The Matplotlib package (<code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code>) contains functions for
this purpose. The names of the functions are similar to the plotting
functions known from MATLAB.  A complete function for creating
the comparison plot becomes</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">plot_numerical_and_exact</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compare the numerical and exact solution in a plot.&quot;&quot;&quot;</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>        <span class="c1"># fine mesh for u_e</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;r--o&#39;</span><span class="p">,</span> <span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">)</span>
    <span class="n">legend</span><span class="p">([</span><span class="s1">&#39;numerical&#39;</span><span class="p">,</span> <span class="s1">&#39;exact&#39;</span><span class="p">])</span>
    <span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">);</span> <span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">title</span><span class="p">(</span><span class="s1">&#39;theta=</span><span class="si">%g</span><span class="s1">, dt=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
    <span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;plot_</span><span class="si">%s</span><span class="s1">_</span><span class="si">%g</span><span class="s1">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
<span class="n">plot_numerical_and_exact</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">savefig</span></code> here creates a PNG file whose name includes the
values of <span class="math notranslate nohighlight">\(\theta\)</span> and <span class="math notranslate nohighlight">\(\Delta t\)</span> so that we can easily distinguish
files from different runs with <span class="math notranslate nohighlight">\(\theta\)</span> and <span class="math notranslate nohighlight">\(\Delta t\)</span>.</p>
<p>The complete code is found in the file
<a class="reference external" href="http://tinyurl.com/ofkw6kc/alg/decay_v2.py">decay_v2.py</a>. The resulting plot
is shown in Figure <a class="reference internal" href="#decay-fig-v2"><span class="std std-ref">Comparison of numerical and exact solution</span></a>. As seen, there is quite some
discrepancy between the exact and the numerical solution.
Fortunately, the numerical solution approaches the exact one as
<span class="math notranslate nohighlight">\(\Delta t\)</span> is reduced.</p>
<figure class="align-default" id="id7">
<span id="decay-fig-v2"></span><a class="reference internal image-reference" href="_images/decay_v2.png"><img alt="_images/decay_v2.png" src="_images/decay_v2.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-text"><em>Comparison of numerical and exact solution</em></span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="verifying-the-implementation">
<h2>Verifying the implementation<a class="headerlink" href="#verifying-the-implementation" title="Permalink to this headline">¶</a></h2>
<p>It is easy to make mistakes while deriving and implementing numerical
algorithms, so we should never believe in the solution before it has
been thoroughly verified.</p>
<div class="admonition-verification-and-validation admonition">
<p class="admonition-title">Verification and validation</p>
<p>The purpose of <em>verifying</em> a program is to bring evidence for the
property that there are no errors in the implementation. A related
term, <em>validate</em> (and <em>validation</em>),
addresses the question if the ODE model is a good
representation of the phenomena we want to simulate. To remember the
difference between verification and validation, verification is
about <em>solving the equations right</em>, while validation is about <em>solving
the right equations</em>. We must always perform a verification before
it is meaningful to believe in the computations and perform validation
(which compares the program results with physical experiments or observations).</p>
</div>
<p>The most obvious idea for verification
in our case is to compare the numerical solution with the exact
solution, when that exists. This is, however, not a particularly good
method. The reason is that there will always
be a discrepancy
between these two solutions, due to numerical
approximations, and we cannot precisely quantify the approximation
errors. The open question is therefore whether we have the
mathematically correct
discrepancy or if we have another, maybe small,
discrepancy due to both an approximation error <em>and</em> an error in the
implementation. It is thus
impossible to judge whether the program is correct or not by
just looking at the graphs in Figure <a class="reference internal" href="#decay-fig-v2"><span class="std std-ref">Comparison of numerical and exact solution</span></a>.</p>
<p>To avoid
mixing the unavoidable numerical approximation errors and the
undesired implementation errors, we should try to make tests where
we have some exact
computation of the discrete solution or at least parts of it.
Examples will show how this can be done.</p>
<section id="running-a-few-algorithmic-steps-by-hand">
<h3>Running a few algorithmic steps by hand<a class="headerlink" href="#running-a-few-algorithmic-steps-by-hand" title="Permalink to this headline">¶</a></h3>
<p>The simplest approach to produce a correct non-trivial reference
solution for the discrete solution <span class="math notranslate nohighlight">\(u\)</span>, is to compute a few steps of
the algorithm by hand. Then we can compare the hand calculations with
numbers produced by the program.</p>
<p>A straightforward approach is to use a calculator and
compute <span class="math notranslate nohighlight">\(u^1\)</span>, <span class="math notranslate nohighlight">\(u^2\)</span>, and <span class="math notranslate nohighlight">\(u^3\)</span>. With <span class="math notranslate nohighlight">\(I=0.1\)</span>, <span class="math notranslate nohighlight">\(\theta=0.8\)</span>,
and <span class="math notranslate nohighlight">\(\Delta t =0.8\)</span> we get</p>
<div class="math notranslate nohighlight">
\[A\equiv \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t} = 0.298245614035\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
u^1 &amp;= AI=0.0298245614035,\\
u^2 &amp;= Au^1= 0.00889504462912,\\
u^3 &amp;=Au^2= 0.00265290804728
\end{align*}\end{split}\]</div>
<span class="target" id="index-7"></span><p id="index-8">Comparison of these manual calculations with the result of the
<code class="docutils literal notranslate"><span class="pre">solver</span></code> function is carried out in the function</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_solver_three_steps</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compare three steps with known manual computations.&quot;&quot;&quot;</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.8</span>
    <span class="n">u_by_hand</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">I</span><span class="p">,</span>
                       <span class="mf">0.0298245614035</span><span class="p">,</span>
                       <span class="mf">0.00889504462912</span><span class="p">,</span>
                       <span class="mf">0.00265290804728</span><span class="p">])</span>

    <span class="n">Nt</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># number of time steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-15</span>  <span class="c1"># tolerance for comparing floats</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_by_hand</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">success</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="k">assert</span> <span class="n">success</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">test_solver_three_steps</span></code> function follows widely used conventions
for <em>unit testing</em>. By following such conventions we can at a later
stage easily execute a big test suite for our software. That is, after
a small modification is made to the program, we can by typing just
a short command, run through a large number of tests to check that the
modifications do not break any computations.
The conventions boil down to three rules:</p>
<blockquote>
<div><ul class="simple">
<li><p>The test function name must start with <code class="docutils literal notranslate"><span class="pre">test_</span></code> and the function cannot take any arguments.</p></li>
<li><p>The test must end up in a boolean expression that is <code class="docutils literal notranslate"><span class="pre">True</span></code> if the test was passed and <code class="docutils literal notranslate"><span class="pre">False</span></code> if it failed.</p></li>
<li><p>The function must run <code class="docutils literal notranslate"><span class="pre">assert</span></code> on the boolean expression, resulting in program abortion (due to an <code class="docutils literal notranslate"><span class="pre">AssertionError</span></code> exception) if the test failed.</p></li>
</ul>
</div></blockquote>
<p>A typical <code class="docutils literal notranslate"><span class="pre">assert</span></code> statement is to check that a computed result <code class="docutils literal notranslate"><span class="pre">c</span></code>
equals the expected value <code class="docutils literal notranslate"><span class="pre">e</span></code>: <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">c</span> <span class="pre">==</span> <span class="pre">e</span></code>. However, since real
numbers are stored in a computer using only 64 units, most numbers
will feature a small rounding error, typically of size <span class="math notranslate nohighlight">\(10^{-16}\)</span>.
That is, real numbers on a computer have finite precision. When doing
arithmetics with finite precision numbers, the rounding errors may
accumulate or not, depending on the algorithm.  It does not make sense
to test <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">e</span></code>, since a small rounding error will cause the test to
fail. Instead, we use an equality with <em>tolerance</em> <code class="docutils literal notranslate"><span class="pre">tol</span></code>: <code class="docutils literal notranslate"><span class="pre">abs(e</span> <span class="pre">-</span> <span class="pre">c)</span>
<span class="pre">&lt;</span> <span class="pre">tol</span></code>. The <code class="docutils literal notranslate"><span class="pre">test_solver_three_steps</span></code> functions applies this type of
test with a tolerance <span class="math notranslate nohighlight">\(01^{-15}\)</span>.</p>
<p>The main program can routinely run the verification test prior to
solving the real problem:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">test_solver_three_steps</span><span class="p">()</span>
<span class="n">plot_numerical_and_exact</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(Rather than calling <code class="docutils literal notranslate"><span class="pre">test_*()</span></code> functions explicitly, one will
normally ask a testing framework like nose
or pytest to find and run such functions.)
The complete program including the verification above is
found in the file <a class="reference external" href="http://tinyurl.com/ofkw6kc/alg/decay_v3.py">decay_v3.py</a>.</p>
</section>
</section>
<section id="computing-the-numerical-error-as-a-mesh-function">
<span id="decay-computing-error"></span><h2>Computing the numerical error as a mesh function<a class="headerlink" href="#computing-the-numerical-error-as-a-mesh-function" title="Permalink to this headline">¶</a></h2>
<p>Now that we have some evidence for a correct implementation, we are in
position to compare the computed <span class="math notranslate nohighlight">\(u^n\)</span> values in the <code class="docutils literal notranslate"><span class="pre">u</span></code> array with
the exact <span class="math notranslate nohighlight">\(u\)</span> values at the mesh points, in order to study the error
in the numerical solution.</p>
<p id="index-9">A natural way to compare the exact and discrete solutions is to
calculate their difference as a mesh function for the error:</p>
<div class="math notranslate nohighlight" id="eq-auto8">
\[\tag{46}
e^n = {u_{\small\mbox{e}}}(t_n) - u^n,\quad n=0,1,\ldots,N_t {\thinspace .}\]</div>
<p>We may view the mesh function
<span class="math notranslate nohighlight">\({u_{\small\mbox{e}}}^n = {u_{\small\mbox{e}}}(t_n)\)</span> as a representation of the continuous function <span class="math notranslate nohighlight">\({u_{\small\mbox{e}}}(t)\)</span>
defined for all <span class="math notranslate nohighlight">\(t\in [0,T]\)</span>. In fact,
<span class="math notranslate nohighlight">\({u_{\small\mbox{e}}}^n\)</span> is often called the <em>representative</em> of
<span class="math notranslate nohighlight">\({u_{\small\mbox{e}}}\)</span> on the mesh. Then, <span class="math notranslate nohighlight">\(e^n = {u_{\small\mbox{e}}}^n - u^n\)</span> is clearly
the difference of two mesh functions.</p>
<p>The error mesh function <span class="math notranslate nohighlight">\(e^n\)</span> can be computed by</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>  <span class="c1"># Numerical sol.</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>             <span class="c1"># Representative of exact sol.</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
</pre></div>
</div>
<p>Note that the mesh functions <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">u_e</span></code> are represented by arrays
and associated with the points in the array <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<span class="target" id="index-10"></span><span class="target" id="index-11"></span><div class="admonition-array-arithmetics admonition" id="index-12">
<p class="admonition-title">Array arithmetics</p>
<p>The last statements</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
</pre></div>
</div>
<p>demonstrate some standard examples of array arithmetics: <code class="docutils literal notranslate"><span class="pre">t</span></code> is an
array of mesh points that we pass to <code class="docutils literal notranslate"><span class="pre">u_exact</span></code>. This function
evaluates <code class="docutils literal notranslate"><span class="pre">-a*t</span></code>, which is a scalar times an array, meaning that
the scalar is multiplied with each array element.
The result is an array, let us call it <code class="docutils literal notranslate"><span class="pre">tmp1</span></code>. Then
<code class="docutils literal notranslate"><span class="pre">exp(tmp1)</span></code> means applying the exponential function to each element in
<code class="docutils literal notranslate"><span class="pre">tmp1</span></code>, giving an array, say <code class="docutils literal notranslate"><span class="pre">tmp2</span></code>. Finally, <code class="docutils literal notranslate"><span class="pre">I*tmp2</span></code> is computed
(scalar times array) and <code class="docutils literal notranslate"><span class="pre">u_e</span></code> refers to this array returned from
<code class="docutils literal notranslate"><span class="pre">u_exact</span></code>. The expression <code class="docutils literal notranslate"><span class="pre">u_e</span> <span class="pre">-</span> <span class="pre">u</span></code> is the difference between
two arrays, resulting in a new array referred to by <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
<p>Replacement of array element computations inside a loop by array
arithmetics is known as <em>vectorization</em>.</p>
</div>
</section>
<section id="computing-the-norm-of-the-error-mesh-function">
<span id="decay-computing-error-norm"></span><h2>Computing the norm of the error mesh function<a class="headerlink" href="#computing-the-norm-of-the-error-mesh-function" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-13"></span><p id="index-14">Instead of working with the error <span class="math notranslate nohighlight">\(e^n\)</span> on the entire mesh, we
often want a single number expressing the size of the error.
This is obtained by taking the norm of the error function.</p>
<p>Let us first define norms of a function <span class="math notranslate nohighlight">\(f(t)\)</span>
defined for all <span class="math notranslate nohighlight">\(t\in [0,T]\)</span>.
Three common norms are</p>
<div class="math notranslate nohighlight" id="eq-decay-norms-l2">
\[\tag{47}
||f||_{L^2} = \left( \int_0^T f(t)^2 dt\right)^{1/2},\]</div>
<div class="math notranslate nohighlight" id="eq-decay-norms-l1">
\[\tag{48}
||f||_{L^1} = \int_0^T |f(t)| dt,\]</div>
<div class="math notranslate nohighlight" id="eq-decay-norms-linf">
\[\tag{49}
||f||_{L^\infty} = \max_{t\in [0,T]}|f(t)|{\thinspace .}\]</div>
<p>The <span class="math notranslate nohighlight">\(L^2\)</span> norm <span class="xref std std-ref">(47)</span> (&quot;L-two norm&quot;)
has nice mathematical properties and
is the most popular norm. It is a generalization
of the well-known Eucledian norm of vectors to functions.
The <span class="math notranslate nohighlight">\(L^1\)</span> norm looks simpler and more intuitive, but has less
nice mathematical properties compared to the two other norms, so
it is much less used in computations.
The <span class="math notranslate nohighlight">\(L^\infty\)</span> is also called the max norm or the supremum norm
and is widely used. It focuses on a single point with the largest
value of <span class="math notranslate nohighlight">\(|f|\)</span>, while the other norms measure average behavior of
the function.</p>
<p>In fact, there is a whole family of norms,</p>
<div class="math notranslate nohighlight" id="eq-auto9">
\[\tag{50}
||f||_{L^p} = \left(\int_0^T f(t)^pdt\right)^{1/p},\]</div>
<p>with <span class="math notranslate nohighlight">\(p\)</span> real. In particular,
<span class="math notranslate nohighlight">\(p=1\)</span> corresponds to the <span class="math notranslate nohighlight">\(L^1\)</span> norm above while <span class="math notranslate nohighlight">\(p=\infty\)</span> is the
<span class="math notranslate nohighlight">\(L^\infty\)</span> norm.</p>
<span class="target" id="index-15"></span><span class="target" id="index-16"></span><p id="index-17">Numerical computations involving mesh functions need corresponding norms.
Given a set of function values, <span class="math notranslate nohighlight">\(f^n\)</span>, and some associated mesh points, <span class="math notranslate nohighlight">\(t_n\)</span>,
a numerical integration rule can be used to calculate the <span class="math notranslate nohighlight">\(L^2\)</span> and
<span class="math notranslate nohighlight">\(L^1\)</span> norms defined above. Imagining that the mesh function is extended
to vary linearly between the mesh points, the Trapezoidal rule is
in fact an exact integration rule. A possible modification of the <span class="math notranslate nohighlight">\(L^2\)</span>
norm for a mesh function <span class="math notranslate nohighlight">\(f^n\)</span> on a uniform mesh with spacing <span class="math notranslate nohighlight">\(\Delta t\)</span>
is therefore the well-known Trapezoidal integration formula</p>
<div class="math notranslate nohighlight">
\[||f^n|| = \left(\Delta t\left(\frac{1}{2}(f^0)^2 + \frac{1}{2}(f^{N_t})^2
+ \sum_{n=1}^{N_t-1} (f^n)^2\right)\right)^{1/2}\]</div>
<p>A common approximation of this expression, motivated by the
convenience of having a simpler formula, is</p>
<div class="math notranslate nohighlight">
\[||f^n||_{\ell^2} = \left(\Delta t\sum_{n=0}^{N_t} (f^n)^2\right)^{1/2} {\thinspace .}\]</div>
<p>This is called the discrete <span class="math notranslate nohighlight">\(L^2\)</span> norm and denoted by <span class="math notranslate nohighlight">\(\ell^2\)</span>.
If <span class="math notranslate nohighlight">\(||f||_{\ell^2}^2\)</span> (i.e., the square of the norm) is used
instead of the Trapezoidal integration formula,
the error
is <span class="math notranslate nohighlight">\(\Delta t((f^0)^2 + (f^{N_t})^2)/2\)</span>. This means that the
weights at the end points of the mesh function are perturbed,
but as <span class="math notranslate nohighlight">\(\Delta t\rightarrow 0\)</span>, the error from this perturbation goes
to zero. As long as we are consistent and
stick to one kind of integration
rule for the norm of a mesh function, the details and accuracy of this
rule is of no concern.</p>
<p>The three discrete norms for a mesh function <span class="math notranslate nohighlight">\(f^n\)</span>, corresponding to
the <span class="math notranslate nohighlight">\(L^2\)</span>, <span class="math notranslate nohighlight">\(L^1\)</span>, and <span class="math notranslate nohighlight">\(L^\infty\)</span> norms of <span class="math notranslate nohighlight">\(f(t)\)</span> defined above, are
defined by</p>
<div class="math notranslate nohighlight" id="id2">
\[\tag{51}
||f^n||_{\ell^2} = \left( \Delta t\sum_{n=0}^{N_t} (f^n)^2\right)^{1/2},\]</div>
<div class="math notranslate nohighlight" id="id3">
\[\tag{52}
||f^n||_{\ell^1} = \Delta t\sum_{n=0}^{N_t} |f^n|,\]</div>
<div class="math notranslate nohighlight" id="id4">
\[\tag{53}
||f^n||_{\ell^\infty} = \max_{0\leq n\leq N_t}|f^n|{\thinspace .}\]</div>
<p>Note that the <span class="math notranslate nohighlight">\(L^2\)</span>, <span class="math notranslate nohighlight">\(L^1\)</span>, <span class="math notranslate nohighlight">\(\ell^2\)</span>, and <span class="math notranslate nohighlight">\(\ell^1\)</span> norms depend on the
length of the interval of interest (think of <span class="math notranslate nohighlight">\(f=1\)</span>, then the
norms are proportional to <span class="math notranslate nohighlight">\(\sqrt{T}\)</span> or <span class="math notranslate nohighlight">\(T\)</span>). In some applications it
is convenient to think of a mesh function as just a vector of function
values without any relation to the interval <span class="math notranslate nohighlight">\([0,T]\)</span>.
Then one can replace <span class="math notranslate nohighlight">\(\Delta t\)</span> by <span class="math notranslate nohighlight">\(T/N_t\)</span> and simply drop <span class="math notranslate nohighlight">\(T\)</span> (which
is just a common scaling factor in the norm,
independent of the vector of function
values). Moreover, people prefer
to divide by the total length of the vector, <span class="math notranslate nohighlight">\(N_t+1\)</span>, instead of <span class="math notranslate nohighlight">\(N_t\)</span>.
This reasoning gives rise to the <em>vector norms</em> for a vector
<span class="math notranslate nohighlight">\(f=(f_0,\ldots,f_{N})\)</span>:</p>
<div class="math notranslate nohighlight" id="eq-decay-norms-vl2">
\[\tag{54}
||f||_2 = \left( \frac{1}{N+1}\sum_{n=0}^{N} (f_n)^2\right)^{1/2},\]</div>
<div class="math notranslate nohighlight" id="eq-decay-norms-vl1">
\[\tag{55}
||f||_1 = \frac{1}{N+1}\sum_{n=0}^{N} |f_n|,\]</div>
<div class="math notranslate nohighlight" id="eq-decay-norms-vlinf">
\[\tag{56}
||f||_{\ell^\infty} = \max_{0\leq n\leq N}|f_n|{\thinspace .}\]</div>
<p>Here we have used the common vector component notation with subscripts
(<span class="math notranslate nohighlight">\(f_n\)</span>) and <span class="math notranslate nohighlight">\(N\)</span> as length. We will mostly work with mesh functions
and use the discrete <span class="math notranslate nohighlight">\(\ell^2\)</span>
norm <span class="xref std std-ref">(51)</span> or the max norm <span class="math notranslate nohighlight">\(\ell^\infty\)</span>
<span class="xref std std-ref">(53)</span>, but the corresponding vector norms
<a class="reference internal" href="#eq-decay-norms-vl2"><span class="std std-ref">(54)</span></a>-<a class="reference internal" href="#eq-decay-norms-vlinf"><span class="std std-ref">(56)</span></a> are also much used
in numerical computations, so it is important to know the different
norms and the relations between them.</p>
<p id="index-18">A single number that expresses the size of the numerical error
will be taken as <span class="math notranslate nohighlight">\(||e^n||_{\ell^2}\)</span> and called <span class="math notranslate nohighlight">\(E\)</span>:</p>
<div class="math notranslate nohighlight" id="eq-decay-e">
\[\tag{57}
E = \sqrt{\Delta t\sum_{n=0}^{N_t} (e^n)^2}\]</div>
<p>The corresponding Python code, using array arithmetics, reads</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">sum</span></code> function comes from <code class="docutils literal notranslate"><span class="pre">numpy</span></code> and computes the sum of the elements
of an array. Also the <code class="docutils literal notranslate"><span class="pre">sqrt</span></code> function is from <code class="docutils literal notranslate"><span class="pre">numpy</span></code> and computes the
square root of each element in the array argument.</p>
<section id="scalar-computing">
<span id="index-19"></span><h3>Scalar computing<a class="headerlink" href="#scalar-computing" title="Permalink to this headline">¶</a></h3>
<p>Instead of doing array computing <code class="docutils literal notranslate"><span class="pre">sqrt(dt*sum(e**2))</span></code> we can compute with
one element at a time:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>     <span class="c1"># length of u array (alt: u.size)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">u_e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># summation variable</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>Such element-wise computing, often called <em>scalar</em> computing, takes
more code, is less readable, and runs much slower than what we
can achieve with array computing.</p>
</section>
</section>
<section id="experiments-with-computing-and-plotting">
<h2>Experiments with computing and plotting<a class="headerlink" href="#experiments-with-computing-and-plotting" title="Permalink to this headline">¶</a></h2>
<p>Let us write down a new function that wraps up the computation and all
the plotting statements used for comparing the exact and numerical
solutions. This function can be called with various <span class="math notranslate nohighlight">\(\theta\)</span> and
<span class="math notranslate nohighlight">\(\Delta t\)</span> values to see how the error depends on the method and mesh
resolution.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run a case with the solver, compute error measure,</span>
<span class="sd">    and plot the numerical and exact solutions (if makeplot=True).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>    <span class="c1"># Numerical solution</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">makeplot</span><span class="p">:</span>
        <span class="n">figure</span><span class="p">()</span>                         <span class="c1"># create new plot</span>
        <span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>       <span class="c1"># fine mesh for u_e</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s1">&#39;r--o&#39;</span><span class="p">)</span>           <span class="c1"># red dashes w/circles</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">)</span>             <span class="c1"># blue line for exact sol.</span>
        <span class="n">legend</span><span class="p">([</span><span class="s1">&#39;numerical&#39;</span><span class="p">,</span> <span class="s1">&#39;exact&#39;</span><span class="p">])</span>
        <span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
        <span class="n">title</span><span class="p">(</span><span class="s1">&#39;theta=</span><span class="si">%g</span><span class="s1">, dt=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">theta2name</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;FE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;BE&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="s1">&#39;CN&#39;</span><span class="p">}</span>
        <span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%g</span><span class="s1">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%g</span><span class="s1">.pdf&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">E</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">figure()</span></code> call is key: without it, a new <code class="docutils literal notranslate"><span class="pre">plot</span></code> command will
draw the new pair of curves in the same plot window, while we want
the different pairs to appear in separate windows and files.
Calling <code class="docutils literal notranslate"><span class="pre">figure()</span></code> ensures this.</p>
<p>Instead of including the <span class="math notranslate nohighlight">\(\theta\)</span> value in the filename to implicitly
inform about the applied method, the code utilizes a little Python
dictionary that maps each relevant <span class="math notranslate nohighlight">\(\theta\)</span> value to a corresponding
acronym for the method name (FE, BE, or CN):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">theta2name</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;FE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;BE&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="s1">&#39;CN&#39;</span><span class="p">}</span>
<span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%g</span><span class="s1">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
</pre></div>
</div>
<span class="target" id="index-20"></span><span class="target" id="index-21"></span><span class="target" id="index-22"></span><p id="index-23">The <code class="docutils literal notranslate"><span class="pre">explore</span></code> function stores the plot in two different image file formats:
PNG and PDF. The PNG format is suitable for
being included in HTML documents, while the PDF format provides
higher quality for LaTeX (i.e., pdfLaTeX) documents.
Frequently used viewers for these
image files on Unix systems are <code class="docutils literal notranslate"><span class="pre">gv</span></code> (comes with Ghostscript)
for the PDF format and
<code class="docutils literal notranslate"><span class="pre">display</span></code> (from the ImageMagick software suite) for PNG files:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Terminal&gt; gv BE_0.5.pdf
Terminal&gt; display BE_0.5.png
</pre></div>
</div>
<p>A main program may run a loop over the three methods (given by
their corresponding <span class="math notranslate nohighlight">\(\theta\)</span> values)
and call <code class="docutils literal notranslate"><span class="pre">explore</span></code> to compute errors and make plots:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt_values</span><span class="p">,</span> <span class="n">theta_values</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
    <span class="nb">print</span> <span class="s1">&#39;theta   dt       error&#39;</span>  <span class="c1"># Column headings in table</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">theta_values</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="nb">print</span> <span class="s1">&#39;</span><span class="si">%4.1f</span><span class="s1"> </span><span class="si">%6.2f</span><span class="s1">: </span><span class="si">%12.3E</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>

<span class="n">main</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">dt_values</span><span class="o">=</span><span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.04</span><span class="p">])</span>
</pre></div>
</div>
<p>The file <a class="reference external" href="http://tinyurl.com/ofkw6kc/alg/decay_plot_mpl.py">decay_plot_mpl.py</a>
contains the complete code with the functions above.
Running this program results in</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Terminal&gt; python decay_plot_mpl.py
theta   dt       error
 0.0   0.40:    2.105E-01
 0.0   0.04:    1.449E-02
 0.5   0.40:    3.362E-02
 0.5   0.04:    1.887E-04
 1.0   0.40:    1.030E-01
 1.0   0.04:    1.382E-02
</pre></div>
</div>
<p>We observe that reducing <span class="math notranslate nohighlight">\(\Delta t\)</span> by a factor of 10 increases the
accuracy for all three methods. We also see that
the combination of <span class="math notranslate nohighlight">\(\theta=0.5\)</span> and a small time step <span class="math notranslate nohighlight">\(\Delta t =0.04\)</span>
gives a much more accurate solution, and that <span class="math notranslate nohighlight">\(\theta=0\)</span> and <span class="math notranslate nohighlight">\(\theta=1\)</span>
with <span class="math notranslate nohighlight">\(\Delta t = 0.4\)</span> result in the least accurate solutions.</p>
<p>Figure <a class="reference internal" href="#decay-fig-fe1"><span class="std std-ref">The Forward Euler scheme for two values of the time step</span></a> demonstrates that the numerical solution
produced by the Forward Euler method with
<span class="math notranslate nohighlight">\(\Delta t=0.4\)</span> clearly lies below the exact curve, but that the
accuracy improves considerably by reducing the time step by a factor
of 10.</p>
<figure class="align-default" id="id8">
<span id="decay-fig-fe1"></span><a class="reference internal image-reference" href="_images/FE1.png"><img alt="_images/FE1.png" src="_images/FE1.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><em>The Forward Euler scheme for two values of the time step</em></span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The behavior of the two other schemes is shown in Figures <a class="reference internal" href="#decay-fig-be1"><span class="std std-ref">The Backward Euler scheme for two values of the time step</span></a>
and <a class="reference internal" href="#decay-fig-cn1"><span class="std std-ref">The Crank-Nicolson scheme for two values of the time step</span></a>. Crank-Nicolson is obviously the most accurate
scheme from this visual point of view.</p>
<figure class="align-default" id="id9">
<span id="decay-fig-be1"></span><a class="reference internal image-reference" href="_images/BE1.png"><img alt="_images/BE1.png" src="_images/BE1.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><em>The Backward Euler scheme for two values of the time step</em></span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id10">
<span id="decay-fig-cn1"></span><a class="reference internal image-reference" href="_images/CN1.png"><img alt="_images/CN1.png" src="_images/CN1.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><em>The Crank-Nicolson scheme for two values of the time step</em></span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<span class="target" id="index-24"></span><section id="combining-plot-files">
<span id="index-25"></span><h3>Combining plot files<a class="headerlink" href="#combining-plot-files" title="Permalink to this headline">¶</a></h3>
<p>Mounting two PNG files beside each other, as done in Figures
<a class="reference internal" href="#decay-fig-fe1"><span class="std std-ref">The Forward Euler scheme for two values of the time step</span></a>-<a class="reference internal" href="#decay-fig-cn1"><span class="std std-ref">The Crank-Nicolson scheme for two values of the time step</span></a>, is easily carried out by the
<a class="reference external" href="http://www.imagemagick.org/script/montage.php">montage</a> program
from the ImageMagick suite:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Terminal&gt; montage -background white -geometry 100% -tile 2x1 \
          FE_0.4.png FE_0.04.png FE1.png
Terminal&gt; convert -trim FE1.png FE1.png
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">-geometry</span></code> argument is used to specify the size of the image. Here,
we preserve the individual sizes of the images. The <code class="docutils literal notranslate"><span class="pre">-tile</span> <span class="pre">HxV</span></code> option
specifies <code class="docutils literal notranslate"><span class="pre">H</span></code> images in the horizontal direction and <code class="docutils literal notranslate"><span class="pre">V</span></code> images in
the vertical direction. A series of image files to be combined are then listed,
with the name of the resulting combined image, here <code class="docutils literal notranslate"><span class="pre">FE1.png</span></code> at the end.
The <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">-trim</span></code> command removes surrounding white areas in the figure
(an operation usually known as <em>cropping</em> in image manipulation programs).</p>
<span class="target" id="index-26"></span><span class="target" id="index-27"></span><p id="index-28">For LaTeX reports it is not recommended to use <code class="docutils literal notranslate"><span class="pre">montage</span></code> and PNG files
as the result has too low resolution. Instead, plots should be made
in the PDF format and combined using the <code class="docutils literal notranslate"><span class="pre">pdftk</span></code>, <code class="docutils literal notranslate"><span class="pre">pdfnup</span></code>, and <code class="docutils literal notranslate"><span class="pre">pdfcrop</span></code> tools
(on Linux/Unix):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Terminal&gt; pdftk FE_0.4.png FE_0.04.png output tmp.pdf
Terminal&gt; pdfnup --nup 2x1 --outfile tmp.pdf tmp.pdf
Terminal&gt; pdfcrop tmp.pdf FE1.png  # output in FE1.png
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">pdftk</span></code> combines images into a multi-page PDF file, <code class="docutils literal notranslate"><span class="pre">pdfnup</span></code>
combines the images in individual pages to a table of images (pages),
and <code class="docutils literal notranslate"><span class="pre">pdfcrop</span></code> removes white margins in the resulting combined image file.</p>
</section>
<section id="plotting-with-scitools">
<h3>Plotting with SciTools<a class="headerlink" href="#plotting-with-scitools" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://github.com/hplgit/scitools">SciTools package</a> provides a
unified plotting interface, called Easyviz, to many different plotting
packages, including Matplotlib, Gnuplot, Grace, MATLAB,
VTK, OpenDX, and VisIt. The syntax is very similar to that of
Matplotlib and MATLAB. In fact, the plotting commands shown above look
the same in SciTool's Easyviz interface, apart from the import
statement, which reads</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>This statement performs a <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">numpy</span> <span class="pre">import</span> <span class="pre">*</span></code> as well as an import
of the most common pieces of the Easyviz (<code class="docutils literal notranslate"><span class="pre">scitools.easyviz</span></code>) package,
along with some additional numerical functionality.</p>
<p>With Easyviz one can
merge several plotting commands into a single one
using keyword arguments:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s1">&#39;r--o&#39;</span><span class="p">,</span>           <span class="c1"># red dashes w/circles</span>
     <span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span>             <span class="c1"># blue line for exact sol.</span>
     <span class="n">legend</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;numerical&#39;</span><span class="p">,</span> <span class="s1">&#39;exact&#39;</span><span class="p">],</span>
     <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">,</span>
     <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span>
     <span class="n">title</span><span class="o">=</span><span class="s1">&#39;theta=</span><span class="si">%g</span><span class="s1">, dt=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">),</span>
     <span class="n">savefig</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%g</span><span class="s1">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">),</span>
     <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference external" href="http://tinyurl.com/ofkw6kc/alg/decay_plot_st.py">decay_plot_st.py</a> file
contains such a demo.</p>
<p>By default, Easyviz employs Matplotlib for plotting, but <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> and <a class="reference external" href="http://plasma-gate.weizmann.ac.il/Grace/">Grace</a> are viable alternatives:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Terminal&gt; python decay_plot_st.py --SCITOOLS_easyviz_backend gnuplot
Terminal&gt; python decay_plot_st.py --SCITOOLS_easyviz_backend grace
</pre></div>
</div>
<p>The actual tool used for creating plots (called <em>backend</em>)
and numerous other options
can be permanently set in SciTool's configuration file.</p>
<p>All the Gnuplot windows are launched without any need to kill one before
the next one pops up (as is the case with Matplotlib) and one can
press the key 'q' anywhere in a plot window to kill it.
Another advantage of Gnuplot is the automatic choice of sensible
and distinguishable line types in black-and-white PDF and PostScript
files.</p>
<p>For more detailed information on syntax and plotting capabilities,
we refer to the Matplotlib <a class="reference internal" href="._main_alg004.html#ref2" id="id5"><span>[Ref2]</span></a>
and SciTools <a class="reference internal" href="._main_alg004.html#ref3" id="id6"><span>[Ref3]</span></a> documentation.
The hope is that
the programming syntax explained so far suffices for understanding the
basic plotting functionality and being able to look up
the cited technical documentation.</p>
</section>
</section>
<section id="memory-saving-implementation">
<h2>Memory-saving implementation<a class="headerlink" href="#memory-saving-implementation" title="Permalink to this headline">¶</a></h2>
<p>The computer memory requirements of our implementations so far consist
mainly of the <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> arrays, both of length <span class="math notranslate nohighlight">\(N_t+1\)</span>.  Also, for
the programs that involve array arithmetics, Python needs memory space
for storing temporary arrays. For example, computing <code class="docutils literal notranslate"><span class="pre">I*exp(-a*t)</span></code>
requires storing the intermediate result <code class="docutils literal notranslate"><span class="pre">a*t</span></code> before the preceding
minus sign can be applied. The resulting array is temporarily stored
and provided as input to the <code class="docutils literal notranslate"><span class="pre">exp</span></code> function.  Regardless of how we
implement simple ODE problems, storage requirements are very modest
and put no restrictions on how we choose our data structures and
algorithms.  Nevertheless, when the presented methods are applied to
three-dimensional PDE problems, memory storage requirements suddenly
become a challenging issue.</p>
<p>Let us briefly elaborate on how large the storage requirements can
quickly be in three-dimensional problems.  The PDE counterpart to our
model problem <span class="math notranslate nohighlight">\(u'=-a\)</span> is a diffusion equation <span class="math notranslate nohighlight">\(u_t = a\nabla^2 u\)</span>
posed on a space-time domain. The discrete representation of this
domain may in 3D be a spatial mesh of <span class="math notranslate nohighlight">\(M^3\)</span> points and a time mesh of
<span class="math notranslate nohighlight">\(N_t\)</span> points.  In many applications, it is quite typical that <span class="math notranslate nohighlight">\(M\)</span> is
at least 100, or even 1000.  Storing all the computed <span class="math notranslate nohighlight">\(u\)</span> values, like
we have done in the programs so far, would demand storing arrays of
size up to <span class="math notranslate nohighlight">\(M^3N_t\)</span>. This would give a factor of <span class="math notranslate nohighlight">\(M^3\)</span> larger storage
demands compared to what was required by our ODE programs. Each real
number in the <code class="docutils literal notranslate"><span class="pre">u</span></code> array requires 8 bytes (b) of storage. With <span class="math notranslate nohighlight">\(M=100\)</span>
and <span class="math notranslate nohighlight">\(N_t=1000\)</span>, there is a storage demand of <span class="math notranslate nohighlight">\((10^3)^3\cdot 1000\cdot
8 = 8\)</span> Gb for the solution array.  Fortunately, we can usually get rid
of the <span class="math notranslate nohighlight">\(N_t\)</span> factor, resulting in 8 Mb of storage.  Below we explain
how this is done (the technique is almost always applied in
implementations of PDE problems).</p>
<p>Let us critically evaluate how much we really need to store in the
computer's memory for our implementation of the <span class="math notranslate nohighlight">\(\theta\)</span> method. To
compute a new <span class="math notranslate nohighlight">\(u^{n+1}\)</span>, all we need is <span class="math notranslate nohighlight">\(u^n\)</span>. This implies that the
previous <span class="math notranslate nohighlight">\(u^{n-1},u^{n-2},\dots,u^0\)</span> values do not need to be stored,
although this is convenient for plotting and data analysis in the
program.  Instead of the <code class="docutils literal notranslate"><span class="pre">u</span></code> array we can work with two variables for
real numbers, <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">u_1</span></code>, representing <span class="math notranslate nohighlight">\(u^{n+1}\)</span> and <span class="math notranslate nohighlight">\(u^n\)</span> in the
algorithm, respectively.  At each time level, we update <code class="docutils literal notranslate"><span class="pre">u</span></code> from <code class="docutils literal notranslate"><span class="pre">u_1</span></code>
and then set <code class="docutils literal notranslate"><span class="pre">u_1</span> <span class="pre">=</span> <span class="pre">u</span></code>, so that the computed <span class="math notranslate nohighlight">\(u^{n+1}\)</span> value becomes
the &quot;previous&quot; value <span class="math notranslate nohighlight">\(u^n\)</span> at the next time level. The downside is
that we cannot plot the solution after the simulation is done since
only the last two numbers are available.  The remedy is to store
computed values in a file and use the file for visualizing the
solution later.</p>
<p>We have implemented this memory saving idea in the file
<a class="reference external" href="http://tinyurl.com/ofkw6kc/alg/decay_memsave.py">decay_memsave.py</a>, which is a
slight modification of <a class="reference external" href="http://tinyurl.com/ofkw6kc/alg/decay_plot_mpl.py">decay_plot_mpl.py</a> program.</p>
<p>The following function demonstrates how we work with the two most
recent values of the unknown:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solver_memsave</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;sol.dat&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.</span>
<span class="sd">    Minimum use of memory. The solution is stored in a file</span>
<span class="sd">    (with name filename) for later plotting.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>         <span class="c1"># avoid integer division</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>  <span class="c1"># no of intervals</span>

    <span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="c1"># u: time level n+1, u_1: time level n</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u_1</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.16E</span><span class="s1">  </span><span class="si">%.16E</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u_1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u_1</span>
        <span class="n">u_1</span> <span class="o">=</span> <span class="n">u</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
        <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.16E</span><span class="s1">  </span><span class="si">%.16E</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>This code snippet also serves as a quick introduction to file writing in Python.
Reading the data in the file into arrays <code class="docutils literal notranslate"><span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">u</span></code> is done by the
function</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;sol.dat&#39;</span><span class="p">):</span>
    <span class="n">infile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="p">[];</span>  <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">infile</span><span class="p">:</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;Found more than two numbers on a line!&#39;</span><span class="p">,</span> <span class="n">words</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># abort</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>This type of file with numbers in rows and columns is very common, and
<code class="docutils literal notranslate"><span class="pre">numpy</span></code> has a function <code class="docutils literal notranslate"><span class="pre">loadtxt</span></code> which loads such tabular data into a
two-dimensional array named by the user. Say the name is <code class="docutils literal notranslate"><span class="pre">data</span></code>, the
number in row <code class="docutils literal notranslate"><span class="pre">i</span></code> and column <code class="docutils literal notranslate"><span class="pre">j</span></code> is then <code class="docutils literal notranslate"><span class="pre">data[i,j]</span></code>.  The whole
column number <code class="docutils literal notranslate"><span class="pre">j</span></code> can be extracted by <code class="docutils literal notranslate"><span class="pre">data[:,j]</span></code>.  A version of
<code class="docutils literal notranslate"><span class="pre">read_file</span></code> using <code class="docutils literal notranslate"><span class="pre">np.loadtxt</span></code> reads</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">read_file_numpy</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;sol.dat&#39;</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span>
</pre></div>
</div>
<p>The present counterpart to the <code class="docutils literal notranslate"><span class="pre">explore</span></code> function from
<a class="reference external" href="http://tinyurl.com/ofkw6kc/alg/decay_plot_mpl.py">decay_plot_mpl.py</a> must run
<code class="docutils literal notranslate"><span class="pre">solver_memsave</span></code> and then load data from file before we can compute
the error measure and make the plot:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;u.dat&#39;</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_memsave</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="n">t</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">read_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">makeplot</span><span class="p">:</span>
        <span class="n">figure</span><span class="p">()</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>Apart from the internal implementation, where <span class="math notranslate nohighlight">\(u^n\)</span> values are stored
in a file rather than in an array, <code class="docutils literal notranslate"><span class="pre">decay_memsave.py</span></code> file works
exactly as the <code class="docutils literal notranslate"><span class="pre">decay_plot_mpl.py</span></code> file.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Implementations</a><ul>
<li><a class="reference internal" href="#computer-language-python">Computer language: Python</a></li>
<li><a class="reference internal" href="#making-a-solver-function">Making a solver function</a></li>
<li><a class="reference internal" href="#integer-division">Integer division</a></li>
<li><a class="reference internal" href="#doc-strings">Doc strings</a></li>
<li><a class="reference internal" href="#formatting-numbers">Formatting numbers</a></li>
<li><a class="reference internal" href="#running-the-program">Running the program</a></li>
<li><a class="reference internal" href="#plotting-the-solution">Plotting the solution</a></li>
<li><a class="reference internal" href="#verifying-the-implementation">Verifying the implementation</a><ul>
<li><a class="reference internal" href="#running-a-few-algorithmic-steps-by-hand">Running a few algorithmic steps by hand</a></li>
</ul>
</li>
<li><a class="reference internal" href="#computing-the-numerical-error-as-a-mesh-function">Computing the numerical error as a mesh function</a></li>
<li><a class="reference internal" href="#computing-the-norm-of-the-error-mesh-function">Computing the norm of the error mesh function</a><ul>
<li><a class="reference internal" href="#scalar-computing">Scalar computing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#experiments-with-computing-and-plotting">Experiments with computing and plotting</a><ul>
<li><a class="reference internal" href="#combining-plot-files">Combining plot files</a></li>
<li><a class="reference internal" href="#plotting-with-scitools">Plotting with SciTools</a></li>
</ul>
</li>
<li><a class="reference internal" href="#memory-saving-implementation">Memory-saving implementation</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="._main_alg001.html"
                          title="previous chapter">Finite difference methods</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="._main_alg003.html"
                          title="next chapter">Exercises</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._main_alg002.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_alg003.html" title="Exercises"
             >next</a> |</li>
        <li class="right" >
          <a href="._main_alg001.html" title="Finite difference methods"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">_ Hans Petter Langtangen documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Implementations</a></li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2023, Algorithms and implementations for exponential decay models.
  </div>
</div>

  </body>
</html>