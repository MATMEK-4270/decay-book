

<!DOCTYPE html>

<html lang="1.0">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Finite difference methods &#8212; _ Hans Petter Langtangen documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/default.css" />
    <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/sidebar.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Implementations" href="._main_alg002.html" />
    <link rel="prev" title="Algorithms and implementations for exponential decay models" href="._main_alg000.html" /> 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_alg002.html" title="Implementations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._main_alg000.html" title="Algorithms and implementations for exponential decay models"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">_ Hans Petter Langtangen documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Finite difference methods</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p>Throughout industry and science it is common today to study nature or
technological devices through models on a computer. With such models
the computer acts as a virtual lab where experiments can be done
in a fast, reliable, safe, and cheap way. In some fields, e.g., aerospace
engineering, the computer models are now so sophisticated that they
can replace physical experiments to a large extent.</p>
<p>A vast amount of computer models are based on ordinary and partial
differential equations. This book is an introduction to the
various scientific ingredients we need for reliable computing with such
type of models. A key theme is to solve differential equations
<em>numerically</em> on a computer. Many methods are available for this purpose,
but the focus here is on <em>finite difference methods</em>, because these
are simple, yet versatile, for solving a wide range of ordinary and
partial differential equations. The present chapter first presents the
mathematical ideas of finite difference methods and derives algorithms,
i.e., formulations of the methods ready for computer programming.
Then we create programs and learn how we can be sure that the programs
really work correctly.</p>
<section id="finite-difference-methods">
<span id="decay-basics"></span><h1>Finite difference methods<a class="headerlink" href="#finite-difference-methods" title="Permalink to this headline">¶</a></h1>
<p>This section explains the basic ideas of finite difference methods
via the simple ordinary differential equation <span class="math notranslate nohighlight">\(u^{\prime}=-au\)</span>.
Emphasis is put on the reasoning around discretization principles and
introduction of key concepts such as mesh, mesh function,
finite difference approximations, averaging in a mesh,
derivation of algorithms, and discrete operator notation.</p>
<section id="a-basic-model-for-exponential-decay">
<span id="decay-model"></span><h2>A basic model for exponential decay<a class="headerlink" href="#a-basic-model-for-exponential-decay" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-0"></span><p id="index-1">Our model problem is perhaps the simplest ordinary differential
equation (ODE):</p>
<div class="math notranslate nohighlight">
\[u^{\prime}(t) = -au(t){\thinspace .}\]</div>
<p>In this equation, <span class="math notranslate nohighlight">\(u(t)\)</span> is a scalar function of time <span class="math notranslate nohighlight">\(t\)</span>,
<span class="math notranslate nohighlight">\(a\)</span> is a constant (in this book we mostly work with <span class="math notranslate nohighlight">\(a&gt;0\)</span>),
and <span class="math notranslate nohighlight">\(u^{\prime}(t)\)</span> means differentiation with
respect to <span class="math notranslate nohighlight">\(t\)</span>. This type of equation arises in a number of
widely different phenomena where some quantity <span class="math notranslate nohighlight">\(u\)</span> undergoes
exponential reduction (provided <span class="math notranslate nohighlight">\(a&gt;0\)</span>).
Examples include radioactive decay, population
decay, investment decay, cooling of an object, pressure decay in the
atmosphere, and retarded motion in fluids. Some models with growth,
<span class="math notranslate nohighlight">\(a &lt; 0\)</span>, are treated as
well.
We have chosen this particular ODE not only because
its applications are relevant, but even more because studying
numerical solution methods for this particular ODE gives important insight
that can be reused in far more complicated settings, in particular
when solving diffusion-type partial differential equations.</p>
<section id="the-exact-solution">
<h3>The exact solution<a class="headerlink" href="#the-exact-solution" title="Permalink to this headline">¶</a></h3>
<p>Although our interest is in <em>approximate</em> numerical solutions of
<span class="math notranslate nohighlight">\(u^{\prime}=-au\)</span>, it is convenient to know the exact analytical
solution of the problem so we can compute the error in numerical
approximations.  The analytical solution of this ODE is found by
separation of variables, which results in</p>
<div class="math notranslate nohighlight">
\[u(t) = Ce^{-at},\]</div>
<p>for any arbitrary constant <span class="math notranslate nohighlight">\(C\)</span>.
To obtain a unique solution, we need a condition to fix the value of <span class="math notranslate nohighlight">\(C\)</span>.
This condition is known as the <em>initial condition</em> and stated as
<span class="math notranslate nohighlight">\(u(0)=I\)</span>. That is, we know that the value of <span class="math notranslate nohighlight">\(u\)</span> is <span class="math notranslate nohighlight">\(I\)</span> when the process
starts at <span class="math notranslate nohighlight">\(t=0\)</span>. With this knowledge, the exact solution becomes
<span class="math notranslate nohighlight">\(u(t)=Ie^{-at}\)</span>. The initial condition is also crucial for numerical
methods: without it, we can never start the numerical algorithms!</p>
</section>
<section id="a-complete-problem-formulation">
<h3>A complete problem formulation<a class="headerlink" href="#a-complete-problem-formulation" title="Permalink to this headline">¶</a></h3>
<p>Besides an initial condition for the ODE, we also need to specify a
time interval for the solution: <span class="math notranslate nohighlight">\(t\in (0,T]\)</span>.
The point <span class="math notranslate nohighlight">\(t=0\)</span> is not
included since we know that <span class="math notranslate nohighlight">\(u(0)=I\)</span> and assume that the equation governs
<span class="math notranslate nohighlight">\(u\)</span> for <span class="math notranslate nohighlight">\(t&gt;0\)</span>.
Let us now summarize the information that is required to
state the complete problem formulation:
find <span class="math notranslate nohighlight">\(u(t)\)</span>
such that</p>
<div class="math notranslate nohighlight" id="eq-decay-problem">
\[\tag{1}
u^{\prime} = -au,\ t\in (0,T], \quad u(0)=I{\thinspace .}\]</div>
<p>This is known as a <em>continuous problem</em> because the parameter <span class="math notranslate nohighlight">\(t\)</span>
varies continuously from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(T\)</span>. For each <span class="math notranslate nohighlight">\(t\)</span> we have a corresponding
<span class="math notranslate nohighlight">\(u(t)\)</span>. There are hence infinitely many values of <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(u(t)\)</span>.
The purpose of a numerical method is to formulate a corresponding
<em>discrete</em> problem whose solution is characterized by a finite number of values,
which can be computed in a finite number of steps on a computer.
Typically, we choose a finite set of time values <span class="math notranslate nohighlight">\(t_0,t_1,\ldots,t_{N_t}\)</span>,
and create algorithms that generate the corresponding <span class="math notranslate nohighlight">\(u\)</span> values
<span class="math notranslate nohighlight">\(u_0,u_1,\ldots,u_{N_t}\)</span>.</p>
</section>
</section>
<section id="the-forward-euler-scheme">
<span id="decay-schemes-fe"></span><h2>The Forward Euler scheme<a class="headerlink" href="#the-forward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>Solving an ODE like <a class="reference internal" href="#eq-decay-problem"><span class="std std-ref">(1)</span></a> by a finite difference method
consists of the following four steps:</p>
<ol class="arabic simple">
<li><p>discretizing the domain,</p></li>
<li><p>requiring fulfillment of the equation at discrete time points,</p></li>
<li><p>replacing derivatives by finite differences,</p></li>
<li><p>formulating a recursive algorithm.</p></li>
</ol>
<span class="target" id="index-2"></span><section id="step-1-discretizing-the-domain">
<span id="index-3"></span><h3>Step 1: Discretizing the domain<a class="headerlink" href="#step-1-discretizing-the-domain" title="Permalink to this headline">¶</a></h3>
<p>The time domain <span class="math notranslate nohighlight">\([0,T]\)</span> is represented by a finite number of
<span class="math notranslate nohighlight">\(N_t+1\)</span> points</p>
<div class="math notranslate nohighlight" id="eq-auto1">
\[\tag{2}
0 = t_0 &lt; t_1 &lt; t_2 &lt; \cdots &lt; t_{N_t-1} &lt; t_{N_t} = T{\thinspace .}\]</div>
<p>The collection of points <span class="math notranslate nohighlight">\(t_0,t_1,\ldots,t_{N_t}\)</span> constitutes a <em>mesh</em>
or <em>grid</em>. Often the mesh points will be uniformly spaced in
the domain <span class="math notranslate nohighlight">\([0,T]\)</span>, which means that the spacing <span class="math notranslate nohighlight">\(t_{n+1}-t_n\)</span> is
the same for all <span class="math notranslate nohighlight">\(n\)</span>. This spacing is often denoted by <span class="math notranslate nohighlight">\(\Delta t\)</span>,
which means that <span class="math notranslate nohighlight">\(t_n=n\Delta t\)</span>.</p>
<p id="index-4">We want the solution <span class="math notranslate nohighlight">\(u\)</span> at the mesh points:
<span class="math notranslate nohighlight">\(u(t_n)\)</span>, <span class="math notranslate nohighlight">\(n=0,1,\ldots,N_t\)</span>.
A notational short-form for <span class="math notranslate nohighlight">\(u(t_n)\)</span>,
which will be used extensively, is <span class="math notranslate nohighlight">\(u^{n}\)</span>. More precisely, we let
<span class="math notranslate nohighlight">\(u^n\)</span> be the <em>numerical approximation</em> to the exact solution <span class="math notranslate nohighlight">\(u(t_n)\)</span>
at <span class="math notranslate nohighlight">\(t=t_n\)</span>.</p>
<p>When we need to clearly distinguish between the numerical and exact solution,
we often place a subscript e on the exact solution, as in <span class="math notranslate nohighlight">\({u_{\small\mbox{e}}}(t_n)\)</span>.
Figure <a class="reference internal" href="#decay-fdu-e"><span class="std std-ref">Time mesh with discrete solution values at points and a dashed line indicating the true solution</span></a> shows the <span class="math notranslate nohighlight">\(t_n\)</span> and <span class="math notranslate nohighlight">\(u^n\)</span> points for <span class="math notranslate nohighlight">\(n=0,1,\ldots,N_t=7\)</span> as well as <span class="math notranslate nohighlight">\({u_{\small\mbox{e}}}(t)\)</span> as the dashed line.</p>
<figure class="align-default" id="id1">
<span id="decay-fdu-e"></span><a class="reference internal image-reference" href="_images/fdm_u_ue.png"><img alt="_images/fdm_u_ue.png" src="_images/fdm_u_ue.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><em>Time mesh with discrete solution values at points and a dashed line indicating the true solution</em></span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>We say that the numerical approximation, i.e.,
the collection of <span class="math notranslate nohighlight">\(u^n\)</span> values for <span class="math notranslate nohighlight">\(n=0,\ldots,N_t\)</span>,
constitutes a <em>mesh function</em>.
A &quot;normal&quot; continuous function is a curve defined for all real <span class="math notranslate nohighlight">\(t\)</span>
values in <span class="math notranslate nohighlight">\([0,T]\)</span>, but a mesh function is only defined at discrete
points in time. If you want to compute the mesh function <em>between</em> the
mesh points, where it is not defined, an <em>interpolation method</em> must be
used. Usually, linear interpolation, i.e., drawing a straight line between
the mesh function values, see Figure <a class="reference internal" href="#decay-fdu-e"><span class="std std-ref">Time mesh with discrete solution values at points and a dashed line indicating the true solution</span></a>, suffices.
To compute the solution for some <span class="math notranslate nohighlight">\(t\in [t_n, t_{n+1}]\)</span>, we use the
linear interpolation formula</p>
<div class="math notranslate nohighlight" id="eq-auto2">
\[\tag{3}
u(t) \approx u^n + \frac{u^{n+1}-u^n}{t_{n+1}-t_n}(t - t_n){\thinspace .}\]</div>
<figure class="align-default" id="id2">
<span id="decay-fdu-ei"></span><a class="reference internal image-reference" href="_images/fdm_u_uei.png"><img alt="_images/fdm_u_uei.png" src="_images/fdm_u_uei.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><em>Linear interpolation between the discrete solution values (dashed curve is exact solution)</em></span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The goal of a numerical solution method for ODEs is
to compute the mesh function by solving a finite set of
<em>algebraic equations</em> derived from the original ODE problem.</p>
</div>
</section>
<section id="step-2-fulfilling-the-equation-at-discrete-time-points">
<h3>Step 2: Fulfilling the equation at discrete time points<a class="headerlink" href="#step-2-fulfilling-the-equation-at-discrete-time-points" title="Permalink to this headline">¶</a></h3>
<p>The ODE is supposed to hold for all <span class="math notranslate nohighlight">\(t\in (0,T]\)</span>, i.e., at an infinite
number of points. Now we relax that requirement and require that
the ODE is fulfilled at a finite set of discrete points in time.
The mesh points <span class="math notranslate nohighlight">\(t_0,t_1,\ldots,t_{N_t}\)</span> are a natural
(but not the only) choice of points.
The original ODE is then reduced to  the following equations:</p>
<div class="math notranslate nohighlight" id="eq-decay-step2">
\[\tag{4}
u^{\prime}(t_n) = -au(t_n),\quad n=0,\ldots,N_t,\quad u(0)=I{\thinspace .}\]</div>
<p>Even though the original ODE is not stated to be valid at <span class="math notranslate nohighlight">\(t=0\)</span>, it
is valid as close to <span class="math notranslate nohighlight">\(t=0\)</span> as we like, and it turns out that it
is useful for construction of numerical methods to have
<a class="reference internal" href="#eq-decay-step2"><span class="std std-ref">(4)</span></a> valid for <span class="math notranslate nohighlight">\(n=0\)</span>. The next two steps show that we
need <a class="reference internal" href="#eq-decay-step2"><span class="std std-ref">(4)</span></a> for <span class="math notranslate nohighlight">\(n=0\)</span>.</p>
</section>
<section id="step-3-replacing-derivatives-by-finite-differences">
<span id="index-5"></span><h3>Step 3: Replacing derivatives by finite differences<a class="headerlink" href="#step-3-replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h3>
<p>The next and most essential step of the method is to replace the
derivative <span class="math notranslate nohighlight">\(u^{\prime}\)</span> by a finite difference approximation. Let us first
try a <em>forward</em> difference approximation (see Figure <a class="reference internal" href="#decay-sketch-fe"><span class="std std-ref">Illustration of a forward difference</span></a>),</p>
<span class="target" id="index-6"></span><div class="math notranslate nohighlight" id="eq-decay-fediff">
<span id="index-7"></span>\[\tag{5}
u^{\prime}(t_n) \approx \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n}{\thinspace .}\]</div>
<p>The name forward relates to the fact that we use a value forward in
time, <span class="math notranslate nohighlight">\(u^{n+1}\)</span>, together with the value <span class="math notranslate nohighlight">\(u^n\)</span> at the point <span class="math notranslate nohighlight">\(t_n\)</span>, where
we seek the derivative, to approximate <span class="math notranslate nohighlight">\(u^{\prime}(t_n)\)</span>.
Inserting this approximation in <a class="reference internal" href="#eq-decay-step2"><span class="std std-ref">(4)</span></a> results in</p>
<div class="math notranslate nohighlight" id="eq-decay-step3">
\[\tag{6}
\frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -au^{n},\quad n=0,1,\ldots,N_t-1{\thinspace .}\]</div>
<p>Note that if we want to compute the solution
up to time level <span class="math notranslate nohighlight">\(N_t\)</span>,
we only need <a class="reference internal" href="#eq-decay-step2"><span class="std std-ref">(4)</span></a> to hold for <span class="math notranslate nohighlight">\(n=0,\ldots,N_t-1\)</span> since
<a class="reference internal" href="#eq-decay-step3"><span class="std std-ref">(6)</span></a> for <span class="math notranslate nohighlight">\(n=N_t-1\)</span> creates an equation for the final
value <span class="math notranslate nohighlight">\(u^{N_t}\)</span>.</p>
<p>Also note that we use the approximation symbol <span class="math notranslate nohighlight">\(\approx\)</span> in <a class="reference internal" href="#eq-decay-fediff"><span class="std std-ref">(5)</span></a>,
but not in <a class="reference internal" href="#eq-decay-step3"><span class="std std-ref">(6)</span></a>. Instead, we view <a class="reference internal" href="#eq-decay-step3"><span class="std std-ref">(6)</span></a> as
an equation that is not mathematically equivalent to <a class="reference internal" href="#eq-decay-fediff"><span class="std std-ref">(5)</span></a>,
but represents an approximation to the equation <a class="reference internal" href="#eq-decay-fediff"><span class="std std-ref">(5)</span></a>.</p>
<p>Equation <a class="reference internal" href="#eq-decay-step3"><span class="std std-ref">(6)</span></a>
is the discrete counterpart to the original ODE problem
<a class="reference internal" href="#eq-decay-problem"><span class="std std-ref">(1)</span></a>, and often referred to as a <em>finite difference scheme</em>
or more generally as the <em>discrete equations</em> of the problem.
The fundamental feature of these equations is that they are <em>algebraic</em>
and can hence be straightforwardly solved to produce the mesh function, i.e.,
the approximate values of <span class="math notranslate nohighlight">\(u\)</span> at
the mesh points: <span class="math notranslate nohighlight">\(u^n\)</span>, <span class="math notranslate nohighlight">\(n=1,2,\ldots,N_t\)</span>.</p>
<figure class="align-default" id="id3">
<span id="decay-sketch-fe"></span><a class="reference internal image-reference" href="_images/fd_forward.png"><img alt="_images/fd_forward.png" src="_images/fd_forward.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-text"><em>Illustration of a forward difference</em></span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<span class="target" id="index-8"></span><span class="target" id="index-9"></span><span class="target" id="index-10"></span><span class="target" id="index-11"></span></section>
<section id="step-4-formulating-a-recursive-algorithm">
<span id="index-12"></span><h3>Step 4: Formulating a recursive algorithm<a class="headerlink" href="#step-4-formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The final step is to identify the computational algorithm to be implemented
in a program. The key observation here is to realize that
<a class="reference internal" href="#eq-decay-step3"><span class="std std-ref">(6)</span></a> can be used to compute <span class="math notranslate nohighlight">\(u^{n+1}\)</span> if <span class="math notranslate nohighlight">\(u^n\)</span> is known.
Starting with <span class="math notranslate nohighlight">\(n=0\)</span>, <span class="math notranslate nohighlight">\(u^0\)</span> is known since <span class="math notranslate nohighlight">\(u^0=u(0)=I\)</span>, and
<a class="reference internal" href="#eq-decay-step3"><span class="std std-ref">(6)</span></a> gives an equation for <span class="math notranslate nohighlight">\(u^1\)</span>. Knowing <span class="math notranslate nohighlight">\(u^1\)</span>,
<span class="math notranslate nohighlight">\(u^2\)</span> can be found from <a class="reference internal" href="#eq-decay-step3"><span class="std std-ref">(6)</span></a>. In general, <span class="math notranslate nohighlight">\(u^n\)</span>
in <a class="reference internal" href="#eq-decay-step3"><span class="std std-ref">(6)</span></a> can be assumed known, and then we can easily solve for
the unknown <span class="math notranslate nohighlight">\(u^{n+1}\)</span>:</p>
<div class="math notranslate nohighlight" id="eq-decay-fe">
\[\tag{7}
u^{n+1} = u^n - a(t_{n+1} -t_n)u^n{\thinspace .}\]</div>
<p>We shall refer to <a class="reference internal" href="#eq-decay-fe"><span class="std std-ref">(7)</span></a> as the Forward Euler (FE) scheme
for our model problem. From a mathematical point of view,
equations of the form <a class="reference internal" href="#eq-decay-fe"><span class="std std-ref">(7)</span></a> are known as
<em>difference equations</em> since they express how differences in
the dependent variable, here <span class="math notranslate nohighlight">\(u\)</span>, evolve with <span class="math notranslate nohighlight">\(n\)</span>. In our case,
the differences in <span class="math notranslate nohighlight">\(u\)</span> are given by <span class="math notranslate nohighlight">\(u^{n+1}-u^n = -a(t_{n+1}-t_n)u^n\)</span>.
The finite difference method can be viewed as a method for turning
a differential equation into an algebraic difference equation that
can be easily solved by repeated use of a formula like <a class="reference internal" href="#eq-decay-fe"><span class="std std-ref">(7)</span></a>.</p>
</section>
<section id="interpretation">
<h3>Interpretation<a class="headerlink" href="#interpretation" title="Permalink to this headline">¶</a></h3>
<p>There is a very intuitive interpretation of the FE scheme, illustrated
in the sketch below. We have computed some point values
on the solution curve (small red disks), and the question is how we reason
about the next point. Since we know <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(t\)</span> at the most recently
computed point, the differential equation gives us the <em>slope</em> of
the solution curve: <span class="math notranslate nohighlight">\(u'=-au\)</span>. We can draw this slope as a red line
and continue the solution curve along that slope. As soon as we have
chosen the next point on this line, we have a new <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(u\)</span> value and
can compute a new slope and continue the process.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/FE_idea.png"><img alt="_images/FE_idea.png" src="_images/FE_idea.png" style="width: 600px;" /></a>
</figure>
</section>
<section id="computing-with-the-recursive-formula">
<h3>Computing with the recursive formula<a class="headerlink" href="#computing-with-the-recursive-formula" title="Permalink to this headline">¶</a></h3>
<p>Mathematical computation with <a class="reference internal" href="#eq-decay-fe"><span class="std std-ref">(7)</span></a> is straightforward:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
u_0 &amp;= I,\\
u_1 &amp; = u^0 - a(t_{1} -t_0)u^0 = I(1-a(t_1-t_0)),\\
u_2 &amp; = u^1 - a(t_{2} -t_1)u^1 = I(1-a(t_1-t_0))(1 - a(t_2-t_1)),\\
u^3 &amp;= u^2 - a(t_{3} -t_2)u^2 = I(1-a(t_1-t_0))(1 - a(t_2-t_1))(1 - a(t_3-t_2)),
\end{align*}\end{split}\]</div>
<p>and so on until we reach <span class="math notranslate nohighlight">\(u^{N_t}\)</span>.
Very often, <span class="math notranslate nohighlight">\(t_{n+1}-t_n\)</span> is constant for all <span class="math notranslate nohighlight">\(n\)</span>, so we can introduce
the common symbol
<span class="math notranslate nohighlight">\(\Delta t = t_{n+1}-t_n\)</span>, <span class="math notranslate nohighlight">\(n=0,1,\ldots,N_t-1\)</span>.
Using a constant mesh spacing <span class="math notranslate nohighlight">\(\Delta t\)</span> in the above calculations gives</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
u_0 &amp;= I,\\
u_1 &amp; = I(1-a\Delta t),\\
u_2 &amp; = I(1-a\Delta t)^2,\\
u^3 &amp;= I(1-a\Delta t)^3,\\
&amp;\vdots\\
u^{N_t} &amp;= I(1-a\Delta t)^{N_t}{\thinspace .}
\end{align*}\end{split}\]</div>
<p>This means that we have found a closed formula for <span class="math notranslate nohighlight">\(u^n\)</span>, and there is
no need to let a computer generate the sequence <span class="math notranslate nohighlight">\(u^1, u^2, u^3, \ldots\)</span>.
However, finding such a formula for <span class="math notranslate nohighlight">\(u^n\)</span> is possible only for a few very
simple problems, so in general finite difference equations must be
solved on a computer.</p>
<p>As the next sections will show, the scheme <a class="reference internal" href="#eq-decay-fe"><span class="std std-ref">(7)</span></a> is just one
out of many alternative finite difference (and other) methods for
the model problem <a class="reference internal" href="#eq-decay-problem"><span class="std std-ref">(1)</span></a>.</p>
</section>
</section>
<section id="the-backward-euler-scheme">
<span id="decay-schemes-be"></span><h2>The Backward Euler scheme<a class="headerlink" href="#the-backward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-13"></span><p id="index-14">There are several choices of difference approximations in step 3 of
the finite difference method as presented in the previous section.
Another alternative is</p>
<div class="math notranslate nohighlight" id="eq-decay-bediff">
\[\tag{8}
u^{\prime}(t_n) \approx \frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}}{\thinspace .}\]</div>
<p>Since this difference is based on going backward in time (<span class="math notranslate nohighlight">\(t_{n-1}\)</span>)
for information, it is known as a <em>backward</em> difference, also called
Backward Euler difference.
Figure <a class="reference internal" href="#decay-sketch-be"><span class="std std-ref">Illustration of a backward difference</span></a> explains the idea.</p>
<figure class="align-default" id="id4">
<span id="decay-sketch-be"></span><a class="reference internal image-reference" href="_images/fd_backward.png"><img alt="_images/fd_backward.png" src="_images/fd_backward.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-text"><em>Illustration of a backward difference</em></span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<span class="target" id="index-15"></span><p id="index-16">Inserting <a class="reference internal" href="#eq-decay-bediff"><span class="std std-ref">(8)</span></a> in <a class="reference internal" href="#eq-decay-step2"><span class="std std-ref">(4)</span></a> yields
the Backward Euler (BE) scheme:</p>
<div class="math notranslate nohighlight" id="eq-decay-be0">
\[\tag{9}
\frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}} = -a u^n,\quad n=1,\ldots,N_t{\thinspace .}\]</div>
<p>We assume, as explained under step 4 in the section <a class="reference internal" href="#decay-schemes-fe"><span class="std std-ref">The Forward Euler scheme</span></a>,
that we have computed <span class="math notranslate nohighlight">\(u^0, u^1, \ldots, u^{n-1}\)</span> such that
<a class="reference internal" href="#eq-decay-be0"><span class="std std-ref">(9)</span></a> can be used to compute <span class="math notranslate nohighlight">\(u^n\)</span>. Note that
<a class="reference internal" href="#eq-decay-be0"><span class="std std-ref">(9)</span></a> needs <span class="math notranslate nohighlight">\(n\)</span> to start at 1 (then it involves <span class="math notranslate nohighlight">\(u^0\)</span>, but
no <span class="math notranslate nohighlight">\(u^{-1}\)</span>) and end at <span class="math notranslate nohighlight">\(N_t\)</span>.</p>
<p>For direct similarity with the formula for the
Forward Euler scheme <a class="reference internal" href="#eq-decay-fe"><span class="std std-ref">(7)</span></a>
we replace <span class="math notranslate nohighlight">\(n\)</span> by <span class="math notranslate nohighlight">\(n+1\)</span> in <a class="reference internal" href="#eq-decay-be0"><span class="std std-ref">(9)</span></a> and solve for the
unknown value <span class="math notranslate nohighlight">\(u^{n+1}\)</span>:</p>
<div class="math notranslate nohighlight" id="eq-decay-be">
\[\tag{10}
u^{n+1} = \frac{1}{1+ a(t_{n+1}-t_n)} u^n,\quad n=0,\ldots,N_t-1{\thinspace .}\]</div>
</section>
<section id="the-crank-nicolson-scheme">
<span id="decay-schemes-cn"></span><h2>The Crank-Nicolson scheme<a class="headerlink" href="#the-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-17"></span><span class="target" id="index-18"></span><p id="index-19">The finite difference approximations
<a class="reference internal" href="#eq-decay-fediff"><span class="std std-ref">(5)</span></a> and <a class="reference internal" href="#eq-decay-bediff"><span class="std std-ref">(8)</span></a> used to derive the schemes
<a class="reference internal" href="#eq-decay-fe"><span class="std std-ref">(7)</span></a> and <a class="reference internal" href="#eq-decay-be"><span class="std std-ref">(10)</span></a>, respectively,
are both one-sided differences, i.e.,
we collect information either forward or backward in time when approximating
the derivative at a point. Such one-sided differences are
known to be less accurate than central (or midpoint)
differences, where we use information both forward and backward in
time. A natural next step is therefore to construct
a central difference approximation that will yield a more accurate
numerical solution.</p>
<p>The central difference approximation to the derivative is sought at the
point <span class="math notranslate nohighlight">\(t_{n+\frac{1}{2}}=\frac{1}{2} (t_n + t_{n+1})\)</span> (or
<span class="math notranslate nohighlight">\(t_{n+\frac{1}{2}}=(n+\frac{1}{2})\Delta t\)</span> if the mesh spacing is uniform in time).
The approximation reads</p>
<div class="math notranslate nohighlight" id="eq-decay-cndiff">
\[\tag{11}
u^{\prime}(t_{n+\frac{1}{2}}) \approx \frac{u^{n+1}-u^n}{t_{n+1}-t_n}{\thinspace .}\]</div>
<p>Figure <a class="reference internal" href="#decay-sketch-cn"><span class="std std-ref">Illustration of a centered difference</span></a> sketches the geometric interpretation of
such a centered difference.
Note that the fraction on the right-hand side is the same as for the
Forward Euler approximation <a class="reference internal" href="#eq-decay-fediff"><span class="std std-ref">(5)</span></a> and
the Backward Euler approximation <a class="reference internal" href="#eq-decay-bediff"><span class="std std-ref">(8)</span></a> (with
<span class="math notranslate nohighlight">\(n\)</span> replaced by <span class="math notranslate nohighlight">\(n+1\)</span>). The accuracy of this fraction as an approximation
to the derivative of <span class="math notranslate nohighlight">\(u\)</span> depends on <em>where</em> we seek the derivative:
in the center of the interval <span class="math notranslate nohighlight">\([t_{n},t_{n+1}]\)</span> or at the end points.
We shall later see that it is more accurate at the center point.</p>
<figure class="align-default" id="id5">
<span id="decay-sketch-cn"></span><a class="reference internal image-reference" href="_images/fd_centered_CN.png"><img alt="_images/fd_centered_CN.png" src="_images/fd_centered_CN.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-text"><em>Illustration of a centered difference</em></span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>With the formula <a class="reference internal" href="#eq-decay-cndiff"><span class="std std-ref">(11)</span></a>, where <span class="math notranslate nohighlight">\(u^{\prime}\)</span> is evaluated at
<span class="math notranslate nohighlight">\(t_{n+\frac{1}{2}}\)</span>, it is natural to demand the
ODE to be fulfilled at the time points <em>between</em> the mesh points:</p>
<div class="math notranslate nohighlight" id="eq-decay-step2m">
\[\tag{12}
u^{\prime}(t_{n+\frac{1}{2}}) = -au(t_{n+\frac{1}{2}}),\quad n=0,
    \ldots,N_t-1{\thinspace .}\]</div>
<p>Using <a class="reference internal" href="#eq-decay-cndiff"><span class="std std-ref">(11)</span></a> in <a class="reference internal" href="#eq-decay-step2m"><span class="std std-ref">(12)</span></a> results in
the approximate discrete equation</p>
<div class="math notranslate nohighlight" id="eq-decay-cn0">
\[\tag{13}
\frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -au^{n+\frac{1}{2}},\quad n=0,\ldots,N_t-1,\]</div>
<p>where <span class="math notranslate nohighlight">\(u^{n+\frac{1}{2}}\)</span> is a short form for the numerical approximation
to <span class="math notranslate nohighlight">\(u(t_{n+\frac{1}{2}})\)</span>.</p>
<p>There is a fundamental problem with the right-hand side of
<a class="reference internal" href="#eq-decay-cn0"><span class="std std-ref">(13)</span></a>: we aim to compute <span class="math notranslate nohighlight">\(u^n\)</span> for integer <span class="math notranslate nohighlight">\(n\)</span>, which means
that <span class="math notranslate nohighlight">\(u^{n+\frac{1}{2}}\)</span> is not a quantity computed by our method. The
quantity must
therefore be
expressed by the quantities that we actually produce, i.e.,
the numerical solution at the
mesh points. One possibility is to approximate <span class="math notranslate nohighlight">\(u^{n+\frac{1}{2}}\)</span>
as an arithmetic mean of the <span class="math notranslate nohighlight">\(u\)</span> values at the neighboring mesh points:</p>
<div class="math notranslate nohighlight" id="eq-decay-uhalfavg">
<span id="index-20"></span>\[\tag{14}
u^{n+\frac{1}{2}} \approx \frac{1}{2} (u^n + u^{n+1}){\thinspace .}\]</div>
<p>Using <a class="reference internal" href="#eq-decay-uhalfavg"><span class="std std-ref">(14)</span></a> in <a class="reference internal" href="#eq-decay-cn0"><span class="std std-ref">(13)</span></a> results in a new
approximate discrete equation</p>
<div class="math notranslate nohighlight" id="eq-decay-cn1">
\[\tag{15}
\frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -a\frac{1}{2} (u^n + u^{n+1}){\thinspace .}\]</div>
<p>There are three approximation steps leading to this formula:
1) the ODE is only valid at discrete points (between the mesh points),
2) the derivative is approximated by a finite difference, and 3) the
value of <span class="math notranslate nohighlight">\(u\)</span> between mesh points is approximated by an arithmetic mean
value. Despite one more approximation than for the Backward and Forward
Euler schemes, the use of a centered difference leads to a more
accurate method.</p>
<p>To formulate a recursive algorithm,
we assume that <span class="math notranslate nohighlight">\(u^n\)</span> is already computed so that <span class="math notranslate nohighlight">\(u^{n+1}\)</span> is the
unknown, which we can solve for:</p>
<div class="math notranslate nohighlight" id="eq-decay-cn">
\[\tag{16}
u^{n+1} = \frac{1-\frac{1}{2} a(t_{n+1}-t_n)}{1 + \frac{1}{2} a(t_{n+1}-t_n)}u^n{\thinspace .}\]</div>
<p>The finite difference scheme <a class="reference internal" href="#eq-decay-cn"><span class="std std-ref">(16)</span></a> is often called
the Crank-Nicolson (CN) scheme or a midpoint or centered scheme.
Note that <a class="reference internal" href="#eq-decay-cn"><span class="std std-ref">(16)</span></a> as well as <a class="reference internal" href="#eq-decay-fe"><span class="std std-ref">(7)</span></a> and <a class="reference internal" href="#eq-decay-be"><span class="std std-ref">(10)</span></a>
apply whether the spacing in the time mesh, <span class="math notranslate nohighlight">\(t_{n+1}-t_n\)</span>, depends on <span class="math notranslate nohighlight">\(n\)</span>
or is constant.</p>
</section>
<section id="the-unifying-theta-rule">
<span id="decay-schemes-theta"></span><h2>The unifying <span class="math notranslate nohighlight">\(\theta\)</span>-rule<a class="headerlink" href="#the-unifying-theta-rule" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-21"></span><span class="target" id="index-22"></span><p id="index-23">The Forward Euler, Backward Euler, and Crank-Nicolson schemes can be
formulated as one scheme with a varying parameter <span class="math notranslate nohighlight">\(\theta\)</span>:</p>
<div class="math notranslate nohighlight" id="eq-decay-th0">
\[ \begin{align}\begin{aligned}\tag{17}
\frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -a (\theta u^{n+1} + (1-\theta) u^{n})\\    {\thinspace .}\end{aligned}\end{align} \]</div>
<p>Observe that</p>
<blockquote>
<div><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\theta =0\)</span> gives the Forward Euler scheme</p></li>
<li><p><span class="math notranslate nohighlight">\(\theta =1\)</span> gives the Backward Euler scheme,</p></li>
<li><p><span class="math notranslate nohighlight">\(\theta =\frac{1}{2}\)</span> gives the Crank-Nicolson scheme.</p></li>
</ul>
</div></blockquote>
<p>One may alternatively choose any other value of <span class="math notranslate nohighlight">\(\theta\)</span> in <span class="math notranslate nohighlight">\([0,1]\)</span>, but
this is not so common since the accuracy and stability of
the scheme do not improve compared
to the values <span class="math notranslate nohighlight">\(\theta=0,1,\frac{1}{2}\)</span>.</p>
<p>As before, <span class="math notranslate nohighlight">\(u^n\)</span> is considered known and <span class="math notranslate nohighlight">\(u^{n+1}\)</span> unknown, so
we solve for the latter:</p>
<div class="math notranslate nohighlight" id="eq-decay-th">
\[\tag{18}
u^{n+1} = \frac{1 - (1-\theta) a(t_{n+1}-t_n)}{1 + \theta a(t_{n+1}-t_n)}{\thinspace .}\]</div>
<p>This scheme is known as the <span class="math notranslate nohighlight">\(\theta\)</span>-rule, or alternatively written as
the &quot;theta-rule&quot;.</p>
<div class="admonition-derivation admonition">
<p class="admonition-title">Derivation</p>
<p>We start with replacing <span class="math notranslate nohighlight">\(u^{\prime}\)</span> by the fraction</p>
<div class="math notranslate nohighlight">
\[\frac{u^{n+1}-u^{n}}{t_{n+1}-t_n},\]</div>
<p>in the Forward Euler, Backward Euler,
and Crank-Nicolson schemes. Then we observe that
the difference between the methods concerns which point this
fraction approximates the derivative. Or in other words, at which point we
sample the ODE. So far this has been the
end points or the midpoint of <span class="math notranslate nohighlight">\([t_n,t_{n+1}]\)</span>. However, we may choose any point
<span class="math notranslate nohighlight">\(\tilde t \in [t_n,t_{n+1}]\)</span>.
The difficulty
is that evaluating the right-hand side <span class="math notranslate nohighlight">\(-au\)</span> at an arbitrary point
faces the same problem as in
the section <a class="reference internal" href="#decay-schemes-cn"><span class="std std-ref">The Crank-Nicolson scheme</span></a>: the point value must be expressed
by the discrete <span class="math notranslate nohighlight">\(u\)</span> quantities that we compute by the scheme, i.e.,
<span class="math notranslate nohighlight">\(u^n\)</span> and <span class="math notranslate nohighlight">\(u^{n+1}\)</span>. Following the averaging idea from
the section <a class="reference internal" href="#decay-schemes-cn"><span class="std std-ref">The Crank-Nicolson scheme</span></a>,
the value of <span class="math notranslate nohighlight">\(u\)</span> at an arbitrary point <span class="math notranslate nohighlight">\(\tilde t\)</span> can be
calculated as a <em>weighted average</em>, which generalizes the arithmetic mean
<span class="math notranslate nohighlight">\(\frac{1}{2} u^n + {\frac{1}{2}}u^{n+1}\)</span>.
The weighted average reads</p>
</div>
<div class="math notranslate nohighlight" id="eq-decay-thetaavg-u">
\[ \begin{align}\begin{aligned} \tag{19}
 u(\tilde t) \approx \theta u^{n+1} + (1-\theta) u^{n},\\where  \( \theta\in [0,1] \)  is a weighting factor.
We can also express  \( \tilde t \)  as a similar weighted average\\.. _Eq:decay:thetaavg_t:\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned} \tag{20}
 \tilde t \approx \theta t_{n+1} + (1-\theta) t_{n}{\thinspace .}\\Let now the ODE hold at the point
 \( \tilde t\in [t_n,t_{n+1}] \) , approximate  \( u^{\prime} \)  by the fraction
 \( (u^{n+1}-u^{n})/(t_{n+1}-t_n) \) , and approximate the right-hand
side  \( -au \)  by the weighted average :ref:`(19) &lt;Eq:decay:thetaavg_u&gt;`.
The result is :ref:`(17) &lt;Eq:decay:th0&gt;`.\end{aligned}\end{align} \]</div>
</section>
<section id="constant-time-step">
<h2>Constant time step<a class="headerlink" href="#constant-time-step" title="Permalink to this headline">¶</a></h2>
<p>All schemes up to now have been formulated for a general non-uniform
mesh in time: <span class="math notranslate nohighlight">\(t_0 &lt; t_1 &lt; \cdots &lt; t_{N_t}\)</span>.
Non-uniform meshes are highly relevant
since one can use many points in regions where <span class="math notranslate nohighlight">\(u\)</span> varies rapidly, and
fewer points in regions where <span class="math notranslate nohighlight">\(u\)</span> is slowly varying. This idea saves
the total number of points and therefore makes it faster to compute the mesh
function <span class="math notranslate nohighlight">\(u^n\)</span>. Non-uniform meshes are used together with
<em>adaptive</em> methods that are able to adjust the time mesh during the
computations.</p>
<p id="index-24">However, a uniformly distributed set of mesh points is not only
convenient, but also
sufficient for many applications. Therefore, it is a very common
choice. We shall
present the finite difference schemes for a uniform point distribution
<span class="math notranslate nohighlight">\(t_n=n\Delta t\)</span>, where <span class="math notranslate nohighlight">\(\Delta t\)</span> is the constant spacing between
the mesh points, also referred to as the <em>time step</em>.
The resulting formulas look simpler and are more
well known.</p>
<div class="admonition-summary-of-schemes-for-constant-time-step admonition">
<p class="admonition-title">Summary of schemes for constant time step</p>
</div>
<div class="math notranslate nohighlight" id="eq-decay-fe-u">
\[ \begin{align}\begin{aligned} \tag{21}
 u^{n+1} = (1 - a\Delta t )u^n  \quad (\hbox{FE})\\.. _Eq:decay:BE:u:\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned} \tag{22}
 u^{n+1} = \frac{1}{1+ a\Delta t} u^n  \quad (\hbox{BE})\\.. _Eq:decay:CN:u:\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned} \tag{23}
 u^{n+1} = \frac{1-\frac{1}{2} a\Delta t}{1 + \frac{1}{2} a\Delta t} u^n \quad (\hbox{CN})\\.. _Eq:decay:th:u:\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[\tag{24}
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n \quad (\theta-\hbox{rule})\]</div>
<p>It is not accidental that we focus on presenting the Forward Euler, Backward
Euler, and Crank-Nicolson schemes. They complement each other with their
different pros and cons, thus providing a useful collection of
solution methods for many differential equation problems.
The unifying notation of the <span class="math notranslate nohighlight">\(\theta\)</span>-rule makes it convenient to
work with all three methods through just one formula. This is
particularly advantageous in computer implementations since one avoids
if-else tests with formulas that have repetitive elements.</p>
</section>
<section id="mathematical-derivation-of-finite-difference-formulas">
<span id="decay-fd-taylor"></span><h2>Mathematical derivation of finite difference formulas<a class="headerlink" href="#mathematical-derivation-of-finite-difference-formulas" title="Permalink to this headline">¶</a></h2>
<p>The finite difference formulas for approximating the first derivative
of a function have so far been somewhat justified through graphical
illustrations in Figures <a class="reference internal" href="#decay-sketch-fe"><span class="std std-ref">Illustration of a forward difference</span></a>, <a class="reference internal" href="#decay-sketch-be"><span class="std std-ref">Illustration of a backward difference</span></a>,
and <a class="reference internal" href="#decay-sketch-cn"><span class="std std-ref">Illustration of a centered difference</span></a>. The task is to approximate the derivative
at a point of a curve using only two function values. By drawing
a straight line through the points, we have some approximation to
the tangent of the curve and use the slope of this line as
an approximation to the derivative. The slope can be computed by
inspecting the figures.</p>
<p>However, we can alternatively derive the finite difference formulas by
pure mathematics. The key tool for this approach is Taylor series,
or more precisely, approximation of functions by lower-order
Taylor polynomials. Given a function <span class="math notranslate nohighlight">\(f(x)\)</span> that is sufficiently
smooth (i.e., <span class="math notranslate nohighlight">\(f(x)\)</span> has &quot;enough derivatives&quot;),
a Taylor polynomial of degree <span class="math notranslate nohighlight">\(m\)</span> can be used to approximate the
value of the function <span class="math notranslate nohighlight">\(f(x)\)</span> if we know the values of <span class="math notranslate nohighlight">\(f\)</span> and its
first <span class="math notranslate nohighlight">\(m\)</span> derivatives at some other point <span class="math notranslate nohighlight">\(x=a\)</span>. The formula for the
Taylor polynomial reads</p>
<div class="math notranslate nohighlight">
\[f(x)  \approx f(a) + f'(a)(x-a) + \frac{1}{2}f''(a)(x-a)^2 +
\frac{1}{6}f'''(a)(x-a)^3 + \cdots \nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-auto3">
\[\tag{25}
\quad + \frac{1}{m!}\frac{df^{(m)}}{dx^m}(a)(x-a)^m{\thinspace .}\]</div>
<p>For a function of time, <span class="math notranslate nohighlight">\(f(t)\)</span>, related to a mesh with spacing <span class="math notranslate nohighlight">\(\Delta t\)</span>,
we often need the Taylor polynomial approximation at <span class="math notranslate nohighlight">\(f(t_n\pm\Delta t)\)</span>
given <span class="math notranslate nohighlight">\(f\)</span> and its derivatives at <span class="math notranslate nohighlight">\(t=t_n\)</span>. Replacing <span class="math notranslate nohighlight">\(x\)</span> by <span class="math notranslate nohighlight">\(t_n+\Delta t\)</span> and
<span class="math notranslate nohighlight">\(a\)</span> by <span class="math notranslate nohighlight">\(t_n\)</span> gives</p>
<div class="math notranslate nohighlight">
\[f(t_n+\Delta t)  \approx f(t_n) + f'(t_n)\Delta t + \frac{1}{2}f''(t_n)
\Delta t^2 +
\frac{1}{6}f'''(t_n)\Delta t^3 + \cdots\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-decay-taylor-fe1">
\[\tag{26}
\quad + \frac{1}{m!}\frac{df^{(m)}}{dx^m}(t_n)\Delta t^m{\thinspace .}\]</div>
<section id="the-forward-difference">
<h3>The forward difference<a class="headerlink" href="#the-forward-difference" title="Permalink to this headline">¶</a></h3>
<p>We can use <a class="reference internal" href="#eq-decay-taylor-fe1"><span class="std std-ref">(26)</span></a> to find an approximation for
<span class="math notranslate nohighlight">\(f'(t_n)\)</span> simply by solving with respect to this quantity:</p>
<div class="math notranslate nohighlight">
\[f'(t_n)  \approx  \frac{f(t_n+\Delta t) - f(t_n)}{\Delta t}
- \frac{1}{2}f''(t_n)\Delta t -
\frac{1}{6}f'''(t_n)\Delta t^2 + \cdots\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-decay-taylor-fe2">
\[\tag{27}
\quad - \frac{1}{m!}\frac{df^{(m)}}{dx^m}(t_n)\Delta t^{m-1}{\thinspace .}\]</div>
<p>By letting <span class="math notranslate nohighlight">\(m\rightarrow\infty\)</span>, this formula is exact, but that is not
so much of practical value. A more interesting observation is that
all the power terms in <span class="math notranslate nohighlight">\(\Delta t\)</span> vanish as <span class="math notranslate nohighlight">\(\Delta t\rightarrow 0\)</span>, i.e.,
the formula</p>
<div class="math notranslate nohighlight" id="eq-decay-taylor-fe3">
\[\tag{28}
f'(t_n) \approx \frac{f(t_n+\Delta t) - f(t_n)}{\Delta t}\]</div>
<p>is exact in the limit <span class="math notranslate nohighlight">\(\Delta t\rightarrow 0\)</span>.</p>
<p>The interesting feature of <a class="reference internal" href="#eq-decay-taylor-fe2"><span class="std std-ref">(27)</span></a> is that we have
a measure of the error in the formula <a class="reference internal" href="#eq-decay-taylor-fe3"><span class="std std-ref">(28)</span></a>: the
error is given by the extra terms on the right-hand side of
<a class="reference internal" href="#eq-decay-taylor-fe2"><span class="std std-ref">(27)</span></a>. We assume that <span class="math notranslate nohighlight">\(\Delta t\)</span> is a small quantity
(<span class="math notranslate nohighlight">\(\Delta t\ll 1\)</span>).
Then <span class="math notranslate nohighlight">\(\Delta t^2\ll\Delta t\)</span>, <span class="math notranslate nohighlight">\(\Delta t^3\ll \Delta t^2\)</span>, and so on,
which means that the first term is the dominating term. This first
term reads <span class="math notranslate nohighlight">\(-\frac{1}{2}f''(t_n)\Delta t\)</span> and can be taken as a
measure of the error in the Forward Euler formula.</p>
</section>
<section id="the-backward-difference">
<h3>The backward difference<a class="headerlink" href="#the-backward-difference" title="Permalink to this headline">¶</a></h3>
<p>To derive the backward difference, we use the Taylor polynomial
approximation at <span class="math notranslate nohighlight">\(f(t_n-\Delta t)\)</span>:</p>
<div class="math notranslate nohighlight">
\[f(t_n-\Delta t) \approx f(t_n) - f'(t_n)\Delta t + \frac{1}{2}f''(t_n)
\Delta t^2 -
\frac{1}{6}f'''(t_n)\Delta t^3+ \cdots\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-decay-taylor-be1">
\[\tag{29}
\quad + \frac{1}{m!}\frac{df^{(m)}}{dx^m}(t_n)\Delta t^m{\thinspace .}\]</div>
<p>Solving with respect to <span class="math notranslate nohighlight">\(f'(t_n)\)</span> gives</p>
<div class="math notranslate nohighlight">
\[f'(t_n) \approx \frac{f(t_n) - f(t_n-\Delta t)}{\Delta t}
+ \frac{1}{2}f''(t_n)\Delta t -
\frac{1}{6}f'''(t_n)\Delta t^2+ \cdots\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-decay-taylor-be2">
\[\tag{30}
\quad - \frac{1}{m!}\frac{df^{(m)}}{dx^m}(t_n)\Delta t^{m-1}{\thinspace .}\]</div>
<p>The term <span class="math notranslate nohighlight">\(\frac{1}{2}f''(t_n)\Delta t\)</span> can be taken as a simple measure of
the approximation error since it will dominate over the other terms
as <span class="math notranslate nohighlight">\(\Delta t\rightarrow 0\)</span>.</p>
</section>
<section id="the-centered-difference">
<h3>The centered difference<a class="headerlink" href="#the-centered-difference" title="Permalink to this headline">¶</a></h3>
<p>The centered difference approximates the derivative at
<span class="math notranslate nohighlight">\(t_n+\frac{1}{2}\Delta t\)</span>. Let us write up the Taylor polynomial
approximations to <span class="math notranslate nohighlight">\(f(t_n)\)</span> and <span class="math notranslate nohighlight">\(f(t_{n+1})\)</span> around <span class="math notranslate nohighlight">\(t_n+\frac{1}{2}\Delta t\)</span>:</p>
<div class="math notranslate nohighlight">
\[f(t_n) \approx f(t_n+\frac{1}{2}\Delta t) -
f'(t_n+\frac{1}{2}\Delta t)\frac{1}{2}\Delta t +
f''(t_n+\frac{1}{2}\Delta t)(\frac{1}{2}\Delta t)^2 -\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-auto4">
\[\tag{31}
\quad f'''(t_n+\frac{1}{2}\Delta t)(\frac{1}{2}\Delta t)^3 + \cdots\]</div>
<div class="math notranslate nohighlight">
\[f(t_{n+1})  \approx f(t_n+\frac{1}{2}\Delta t) +
f'(t_n+\frac{1}{2}\Delta t)\frac{1}{2}\Delta t +
f''(t_n+\frac{1}{2}\Delta t)(\frac{1}{2}\Delta t)^2 +\nonumber\]</div>
<div class="math notranslate nohighlight" id="eq-auto5">
\[\tag{32}
\quad f'''(t_n+\frac{1}{2}\Delta t)(\frac{1}{2}\Delta t)^3 + \cdots\]</div>
<p>Subtracting the first from the second gives</p>
<div class="math notranslate nohighlight" id="eq-decay-taylor-cn2">
\[\tag{33}
f(t_{n+1}) - f(t_n) = f'(t_n+\frac{1}{2}\Delta t)\Delta t
    + 2f'''(t_n+\frac{1}{2}\Delta t)(\frac{1}{2}\Delta t)^3 + \cdots\]</div>
<p>Solving with respect to <span class="math notranslate nohighlight">\(f'(t_n+\frac{1}{2}\Delta t)\)</span> results
in</p>
<div class="math notranslate nohighlight" id="eq-decay-taylor-cn3">
\[\tag{34}
f'(t_n+\frac{1}{2}\Delta t) \approx \frac{f(t_{n+1}) - f(t_n)}{\Delta t}
    - \frac{1}{4}f'''(t_n+\frac{1}{2}\Delta t)\Delta t^2 + c
    \cdots\]</div>
<p>This time the error measure goes like <span class="math notranslate nohighlight">\(\frac{1}{4}f'''\Delta t^2\)</span>, i.e.,
it is proportional to <span class="math notranslate nohighlight">\(\Delta t^2\)</span> and not only <span class="math notranslate nohighlight">\(\Delta t\)</span>, which means
that the error goes faster to zero as <span class="math notranslate nohighlight">\(\Delta t\)</span> is reduced.
This means that the centered difference formula</p>
<div class="math notranslate nohighlight" id="eq-decay-taylor-cn4">
\[\tag{35}
f'(t_n+\frac{1}{2}\Delta t) \approx \frac{f(t_{n+1}) - f(t_n)}{\Delta t}\]</div>
<p>is more accurate than the forward and backward differences for small
<span class="math notranslate nohighlight">\(\Delta t\)</span>.</p>
</section>
</section>
<section id="compact-operator-notation-for-finite-differences">
<span id="decay-fd-op"></span><h2>Compact operator notation for finite differences<a class="headerlink" href="#compact-operator-notation-for-finite-differences" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-25"></span><p id="index-26">Finite difference formulas can be tedious to write and read,
especially for differential equations with many terms and many
derivatives. To save space and help the reader spot the nature of the
difference approximations, we introduce a compact notation. For a
function <span class="math notranslate nohighlight">\(u(t)\)</span>, a forward difference approximation is denoted by the
<span class="math notranslate nohighlight">\(D_t^+\)</span> operator and written as</p>
<div class="math notranslate nohighlight" id="eq-fd-d-f">
\[\tag{36}
[D_t^+u]^n = \frac{u^{n+1} - u^{n}}{\Delta t}
    \ \left( \approx \frac{d}{dt} u(t_n)\right)
    {\thinspace .}\]</div>
<p>The notation consists of an operator that approximates differentiation
with respect to an independent variable, here <span class="math notranslate nohighlight">\(t\)</span>.  The operator is
built of the symbol <span class="math notranslate nohighlight">\(D\)</span>, with the independent variable as subscript
and a superscript denoting the type of difference. The superscript
<span class="math notranslate nohighlight">\(\,{}^+\)</span> indicates a forward difference.  We place square brackets
around the operator and the function it operates on and specify the
mesh point, where the operator is acting, by a superscript after the
closing bracket.</p>
<p>The corresponding operator notation for a centered difference and
a backward difference reads</p>
<div class="math notranslate nohighlight" id="eq-fd-d-c">
\[\tag{37}
[D_tu]^n = \frac{u^{n+\frac{1}{2}} - u^{n-\frac{1}{2}}}{\Delta t}
    \approx \frac{d}{dt} u(t_n),\]</div>
<p>and</p>
<div class="math notranslate nohighlight" id="eq-fd-d-b">
\[\tag{38}
[D_t^-u]^n = \frac{u^{n} - u^{n-1}}{\Delta t}
    \approx \frac{d}{dt} u(t_n)
    {\thinspace .}\]</div>
<p>Note that the superscript <span class="math notranslate nohighlight">\(\,{}^-\)</span> denotes the backward
difference, while no superscript implies a central difference.</p>
<p>An averaging operator is also convenient to have:</p>
<div class="math notranslate nohighlight" id="eq-fd-mean-a">
\[\tag{39}
[\overline{u}^{t}]^n = \frac{1}{2} (u^{n-\frac{1}{2}} + u^{n+\frac{1}{2}} )
    \approx u(t_n)\]</div>
<p>The superscript <span class="math notranslate nohighlight">\(t\)</span> indicates that the average is taken along the time
coordinate. The common average <span class="math notranslate nohighlight">\((u^n + u^{n+1})/2\)</span> can now be
expressed as <span class="math notranslate nohighlight">\([\overline{u}^{t}]^{n+\frac{1}{2}}\)</span>. (When also spatial coordinates
enter the problem, we need the explicit specification of the coordinate
after the bar.)</p>
<p>With our compact notation, the Backward Euler finite difference approximation to <span class="math notranslate nohighlight">\(u^{\prime}=-au\)</span> can be written
as</p>
<div class="math notranslate nohighlight">
\[[D_t^-u]^n = -au^n {\thinspace .}\]</div>
<p>In difference equations we often place the square brackets around
the whole equation, to indicate at which mesh point the equation applies,
since each term must be approximated at the same point:</p>
<div class="math notranslate nohighlight" id="eq-auto6">
\[\tag{40}
[D_t^- u  = -au]^n {\thinspace .}\]</div>
<p>Similarly, the Forward Euler scheme takes the form</p>
<div class="math notranslate nohighlight" id="eq-auto7">
\[\tag{41}
[D_t^+ u  = -au]^n,\]</div>
<p>while the Crank-Nicolson scheme is written as</p>
<div class="math notranslate nohighlight" id="eq-fd-compact-ex-cn">
\[\tag{42}
[D_t u = -a\overline{u}^t]^{n+\frac{1}{2}}{\thinspace .}\]</div>
<div class="admonition-question admonition">
<p class="admonition-title">Question</p>
<p>By use of <a class="reference internal" href="#eq-fd-d-c"><span class="std std-ref">(37)</span></a> and <a class="reference internal" href="#eq-fd-mean-a"><span class="std std-ref">(39)</span></a>, are you able to
write out the expressions in <a class="reference internal" href="#eq-fd-compact-ex-cn"><span class="std std-ref">(42)</span></a> to verify that
it is indeed the Crank-Nicolson scheme?</p>
</div>
<p>The <span class="math notranslate nohighlight">\(\theta\)</span>-rule can be specified in operator notation by</p>
<div class="math notranslate nohighlight" id="eq-decay-fd1-op-theta">
\[\tag{43}
[\bar D_t u = -a\overline{u}^{t,\theta}]^{n+\theta},{\thinspace .}\]</div>
<p>We define a new time difference</p>
<div class="math notranslate nohighlight" id="eq-decay-fd1-du-theta">
\[\tag{44}
\lbrack\bar D_t u\rbrack^{n+\theta} = \frac{u^{n+1}-u^n}{t^{n+1}-t^n},\]</div>
<p>to be applied at the time point <span class="math notranslate nohighlight">\(t_{n+\theta}\approx\theta t_n + (1-\theta)t_{n+1}\)</span>. This weighted average gives rise to the
<em>weighted averaging operator</em></p>
<div class="math notranslate nohighlight" id="eq-decay-fd1-wmean-a">
\[\tag{45}
\lbrack\overline{u}^{t,\theta}\rbrack^{n+\theta} = (1-\theta)u^{n} + \theta u^{n+1}
    \approx u(t_{n+\theta}),\]</div>
<p>where <span class="math notranslate nohighlight">\(\theta\in [0,1]\)</span> as usual. Note that for <span class="math notranslate nohighlight">\(\theta =\frac{1}{2}\)</span> we recover
the standard centered difference and the standard arithmetic mean.
The idea in <a class="reference internal" href="#eq-decay-fd1-op-theta"><span class="std std-ref">(43)</span></a> is to sample the equation at
<span class="math notranslate nohighlight">\(t_{n+\theta}\)</span>, use a non-symmetric difference at that
point <span class="math notranslate nohighlight">\([\bar D_t u]^{n+\theta}\)</span>, and a weighted (non-symmetric) mean value.</p>
<p>An alternative and perhaps clearer notation is</p>
<div class="math notranslate nohighlight">
\[[D_t u]^{n+\frac{1}{2}} = \theta [-au]^{n+1} + (1-\theta)[-au]^{n}{\thinspace .}\]</div>
<p>Looking at the various examples above and comparing them with the
underlying differential equations, we see immediately which difference
approximations that have been used and at which point they
apply. Therefore, the compact notation effectively communicates the
reasoning behind turning a differential equation into a difference
equation.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Finite difference methods</a><ul>
<li><a class="reference internal" href="#a-basic-model-for-exponential-decay">A basic model for exponential decay</a><ul>
<li><a class="reference internal" href="#the-exact-solution">The exact solution</a></li>
<li><a class="reference internal" href="#a-complete-problem-formulation">A complete problem formulation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-forward-euler-scheme">The Forward Euler scheme</a><ul>
<li><a class="reference internal" href="#step-1-discretizing-the-domain">Step 1: Discretizing the domain</a></li>
<li><a class="reference internal" href="#step-2-fulfilling-the-equation-at-discrete-time-points">Step 2: Fulfilling the equation at discrete time points</a></li>
<li><a class="reference internal" href="#step-3-replacing-derivatives-by-finite-differences">Step 3: Replacing derivatives by finite differences</a></li>
<li><a class="reference internal" href="#step-4-formulating-a-recursive-algorithm">Step 4: Formulating a recursive algorithm</a></li>
<li><a class="reference internal" href="#interpretation">Interpretation</a></li>
<li><a class="reference internal" href="#computing-with-the-recursive-formula">Computing with the recursive formula</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-backward-euler-scheme">The Backward Euler scheme</a></li>
<li><a class="reference internal" href="#the-crank-nicolson-scheme">The Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#the-unifying-theta-rule">The unifying <span class="math notranslate nohighlight">\(\theta\)</span>-rule</a></li>
<li><a class="reference internal" href="#constant-time-step">Constant time step</a></li>
<li><a class="reference internal" href="#mathematical-derivation-of-finite-difference-formulas">Mathematical derivation of finite difference formulas</a><ul>
<li><a class="reference internal" href="#the-forward-difference">The forward difference</a></li>
<li><a class="reference internal" href="#the-backward-difference">The backward difference</a></li>
<li><a class="reference internal" href="#the-centered-difference">The centered difference</a></li>
</ul>
</li>
<li><a class="reference internal" href="#compact-operator-notation-for-finite-differences">Compact operator notation for finite differences</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="._main_alg000.html"
                          title="previous chapter">Algorithms and implementations for exponential decay models</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="._main_alg002.html"
                          title="next chapter">Implementations</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._main_alg001.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_alg002.html" title="Implementations"
             >next</a> |</li>
        <li class="right" >
          <a href="._main_alg000.html" title="Algorithms and implementations for exponential decay models"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">_ Hans Petter Langtangen documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Finite difference methods</a></li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2023, Algorithms and implementations for exponential decay models.
  </div>
</div>

  </body>
</html>